<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="cn"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://dams.net.cn/feed.xml" rel="self" type="application/atom+xml"/><link href="https://dams.net.cn/" rel="alternate" type="text/html" hreflang="cn"/><updated>2025-05-10T11:47:24+00:00</updated><id>https://dams.net.cn/feed.xml</id><title type="html">DAMS</title><entry><title type="html">第一章实验</title><link href="https://dams.net.cn/book/2025/lab1/" rel="alternate" type="text/html" title="第一章实验"/><published>2025-04-01T08:00:00+00:00</published><updated>2025-04-01T08:00:00+00:00</updated><id>https://dams.net.cn/book/2025/lab1</id><content type="html" xml:base="https://dams.net.cn/book/2025/lab1/"><![CDATA[<h1 id="实验一搭建-kvm-虚拟化平台">实验一：搭建 KVM 虚拟化平台</h1> <h2 id="安装-host-系统">安装 Host 系统</h2> <blockquote> <p>本小节为物理机安装 ubuntu 双系统说明，如采用 VMWare 等虚拟工作站方式作为运行环境可直接跳转下一小节。</p> </blockquote> <ul> <li> <p>Ubuntu 20.04 LTS 镜像</p> <ul> <li>下载地址：<a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/20.04/">清华源下载ubuntu-20.04.5-desktop-amd64.iso</a></li> <li>20.04自带内核版本为 Linux5.15，与本书研究对象一致。</li> </ul> </li> <li> <p>制作U盘启动盘</p> <p>MacOS 系统可采用 <code class="language-plaintext highlighter-rouge">dd</code> 命令将U盘制作成 ubuntu 系统启动盘（windows 系统可采用 Rufus 工具）。</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>diskutil list
/dev/disk0 <span class="o">(</span>internal, physical<span class="o">)</span>:
   <span class="c">#:                       TYPE NAME                    SIZE       IDENTIFIER</span>
   0:      GUID_partition_scheme                        <span class="k">*</span>251.0 GB   disk0
   1:                        EFI EFI                     314.6 MB   disk0s1
   2:                 Apple_APFS Container disk1         250.7 GB   disk0s2

/dev/disk1 <span class="o">(</span>synthesized<span class="o">)</span>:
   <span class="c">#:                       TYPE NAME                    SIZE       IDENTIFIER</span>
   0:      APFS Container Scheme -                      +250.7 GB   disk1
                                 Physical Store disk0s2
   1:                APFS Volume Macintosh HD - 数据     188.9 GB   disk1s1
   2:                APFS Volume Preboot                 2.2 GB     disk1s2
   3:                APFS Volume Recovery                1.1 GB     disk1s3
   4:                APFS Volume VM                      8.6 GB     disk1s4
   5:                APFS Volume Macintosh HD            21.5 GB    disk1s5
   6:              APFS Snapshot com.apple.os.update-... 21.5 GB    disk1s5s1

/dev/disk2 <span class="o">(</span>external, physical<span class="o">)</span>:
   <span class="c">#:                       TYPE NAME                    SIZE       IDENTIFIER</span>
   0:     FDisk_partition_scheme                        <span class="k">*</span>7.8 GB     disk2
   1:             Windows_FAT_32 TESTONLY                7.8 GB     disk2s4

<span class="nv">$ </span>diskutil unmountDisk /dev/disk2
Unmount of all volumes on disk2 was successful
<span class="nv">$ </span><span class="nb">sudo dd </span><span class="k">if</span><span class="o">=</span>/Users/challenge/Downloads/ubuntu-20.04.5-desktop-amd64.iso <span class="nv">of</span><span class="o">=</span>/dev/rdisk2 <span class="nv">bs</span><span class="o">=</span>1m
Password:

3685+1 records <span class="k">in
</span>3685+1 records out
3864182784 bytes transferred <span class="k">in </span>625.176597 secs <span class="o">(</span>6180946 bytes/sec<span class="o">)</span>
</code></pre></div> </div> </li> <li> <p>安装双系统</p> <ul> <li>修改bios启动顺序 U盘优先（华硕主板开机界面按 F2 进入）</li> <li>进入ubuntu安装，选择新的硬盘即可</li> <li>重启拔掉U盘</li> </ul> </li> <li> <p>重启后可能会遇到死机进入grub命令界面</p> <ul> <li> <p>首先通过ls命令显示出硬盘分区信息，目的是找到boot/grub所在位置</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>grub&gt; <span class="nb">ls</span> <span class="o">(</span>h
Possible devices are:
hd0 hd1

grub› <span class="nb">ls</span> <span class="o">(</span>hd0,gpt
Possible partitions are:
	Partition hd0,gpt1: Filesystem <span class="nb">type </span>fat, UUID 890D-5C71 - Partition start at 1024K1B - Total size 524288KiB
	Partition hd0,gpt2: Filesystem <span class="nb">type </span>ext<span class="k">*</span> - Last modification <span class="nb">time </span>2023-03-23 09:33:27 Thursday, UUID 161f2ec0-a71c-4917-8abb-e4c558884663 - Partition start at 525312K1B - Total size 976236544KiB

grub&gt; <span class="nb">ls</span> <span class="o">(</span>hd0, gpt2<span class="o">)</span> /
Possible files are:
	lost+found/ boot/ swapfile etc/ media/ var/ bin/ dev/ home/ lib/ 11664/ mnt/ opt/ proc/ root/ run/ sbin/ snap/ srv/ sys/ tmp/ usr/ initrd.img initrd.img.old vmlinuz vmlinuz.old cdrom/ .cache/ lib32/ libx32/

grub&gt; <span class="nb">ls</span> <span class="o">(</span>hd0,gpt2<span class="o">)</span>/boot/grub/
Possible files are:
	gfxblacklist.txt unicode.pf2 x86_64-efi/ locale/ fonts/ grubenv grub.cfg
</code></pre></div> </div> </li> <li> <p>如上我们发现 (hd0, gpt2) / 下有boot/grub信息，再设置相应的入口</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>grub&gt; <span class="nb">set </span><span class="nv">root</span><span class="o">=(</span>hd0, gpt2<span class="o">)</span>
grub&gt; <span class="nb">set </span><span class="nv">prefix</span><span class="o">=(</span>hd0,gpt2<span class="o">)</span>/boot/grub
grub&gt; insmod normal
grub&gt; normal
</code></pre></div> </div> </li> <li> <p>然后便进入了系统选择页面，选择进入ubuntu20.04，再在终端命令行运行以下命令修复grub</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nv">$ </span><span class="nb">sudo </span>update-grub
  <span class="o">[</span><span class="nb">sudo</span><span class="o">]</span> password <span class="k">for </span>chalnan:
  Sourcing file <span class="s1">'/etc/default/grub'</span>
  Sourcing file <span class="s1">'etc/default/grub.d/init-select.cfg'</span>
  Generating grub configuration file ...
  Found linux image: /boot/vmlinuz-5.15.0-67-generic
  Found initrd image: /boot/initrd.img-5.15.0-67-generic
  Found linux image: /boot/vmlinuz-5.15.0-60-generic
  Found initrd image: /boot/initrd.img-5.15.0-60-generic
  Found linux image: /boot/vmlinuz-5.15.0
  Found initrd image: /boot/initrd.img-5.15.0
  Found Ubuntu 18.04.5 LTS <span class="o">(</span>18.04<span class="o">)</span> on /dev/sda2
  Adding boot menu entry <span class="k">for </span>UEFI Firmware Settings
  <span class="k">done</span>
  <span class="nv">$ </span>lsblk
  NAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT
  sda           8:0    0 931.5G  0 disk
  ├─sda1        8:1    0   512M  0 part /boot/efi
  └─sda2        8:2    0   931G  0 part
  sr0          11:0    1  1024M  0 rom
  nvme0n1     259:0    0 931.5G  0 disk
  └─nvme0n1p1 259:1    0 931.5G  0 part /
  <span class="nv">$ </span><span class="nb">sudo </span>grub-install /dev/nvme0n1
  Installing <span class="k">for </span>x86_64-efi platform.
  Installation finished. No error reported.

</code></pre></div> </div> </li> <li> <p>重启后，可以正常引导启动进入ubuntu的图形界面系统。</p> </li> </ul> </li> </ul> <h2 id="源码编译安装-linux-内核">源码编译安装 Linux 内核</h2> <ul> <li><a href="https://mirrors.tuna.tsinghua.edu.cn/kernel/v5.x/linux-5.15.tar.gz">清华源下载linux-5.15.tar.gz</a></li> </ul> <h3 id="检查硬件系统支持">检查硬件系统支持</h3> <p>检查 CPU 是否支持 KVM 虚拟化。在 x86 和 x86-64 中，Intel 系列 CPU 支持虚拟化的标志为 vmx，AMD 系列 CPU 的标志为 svm ，如下命令行如有输出则表示 CPU 支持硬件虚拟化。</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">grep</span> <span class="nt">-E</span> <span class="s1">'(vmx|svm)'</span> /proc/cpuinfo
</code></pre></div></div> <h3 id="配置内核">配置内核</h3> <p>安装基础开发工具软件包，该命令会安装一系列软件包，包括 <code class="language-plaintext highlighter-rouge">gcc</code>, <code class="language-plaintext highlighter-rouge">make</code>。</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt update
<span class="nb">sudo </span>apt <span class="nb">install </span>build-essential
</code></pre></div></div> <p>安装 ncurses libraries、flex bison 依赖库</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt-get <span class="nb">install </span>ncurses-dev flex bison
</code></pre></div></div> <p>清空现有的配置文件</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make clean
make mrproper
</code></pre></div></div> <p>拷贝系统原生config文件 或者 调用默认配置文件生成config</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cp</span> /boot/config-5.15.0-70-generic .config
</code></pre></div></div> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make defconfig
</code></pre></div></div> <p>然后使用可视化的配置选项，检查/增加 KVM 支持</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make menuconfig
</code></pre></div></div> <p>选择 Virtualization ，选中 KVM 等支持，保存并退出。</p> <p>需要再检查一下证书相关的配置（不然之后 make 会报错）</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vim .config
</code></pre></div></div> <p>检查 <code class="language-plaintext highlighter-rouge">CONFIG_SYSTEM_TRUSTED_KEYS</code> 和 <code class="language-plaintext highlighter-rouge">CONFIG_SYSTEM_REVOCATION_KEYS</code>的值是否为空值。</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>原有值：
<span class="nv">CONFIG_SYSTEM_TRUSTED_KEYS</span><span class="o">=</span><span class="s2">"debian/canonical-certs.pem"</span>
<span class="nv">CONFIG_SYSTEM_REVOCATION_KEYS</span><span class="o">=</span><span class="s2">"debian/canonical-revoked-certs.pem"</span>
改为：
<span class="nv">CONFIG_SYSTEM_TRUSTED_KEYS</span><span class="o">=</span><span class="s2">""</span>
<span class="nv">CONFIG_SYSTEM_REVOCATION_KEYS</span><span class="o">=</span><span class="s2">""</span>
</code></pre></div></div> <h3 id="编译内核">编译内核</h3> <p>安装编译依赖</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt <span class="nb">install </span>libssl-dev libelf-dev dwarves zstd
</code></pre></div></div> <p>编译 kernel，-j 参数表示并行编译，本机器逻辑 cpu 的数量为8，因此选择 -j8。逻辑 cpu 的数量可通过如下命令返回：</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> /proc/cpuinfo | <span class="nb">grep</span> <span class="s2">"processor"</span> |wc <span class="nt">-l</span>
</code></pre></div></div> <p>编译</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make <span class="nt">-j8</span>
</code></pre></div></div> <h3 id="安装内核">安装内核</h3> <p>安装 module</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make modules_install
</code></pre></div></div> <p>以上命令将 module 安装到相应的目录中，默认情况下被安装到 <code class="language-plaintext highlighter-rouge">/lib/modules/$kernel_version/kernel</code> 目录之中，安装完之后可以查看 KVM 模块：</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">ls</span> <span class="nt">-l</span> /lib/modules/5.15.0/kernel/arch/x86/kvm/
</code></pre></div></div> <p>安装 kernel 和 initramfs</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make <span class="nb">install</span>
</code></pre></div></div> <p>此时可见 <code class="language-plaintext highlighter-rouge">/boot</code> 目录下生成了内核（vmlinuz）和 initramfs 等内核启动所需的文件， grub 配置文件中自动添加了一个 grub 选项</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">ls</span> <span class="nt">-l</span> /boot/
<span class="nb">cat</span> /boot/grub/grub.cfg |grep menuentry
</code></pre></div></div> <p>更改 grub 配置文件</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vim /etc/default/grub
<span class="c"># 注释掉GRUB_TIMEOUT_STYLE并将GRUB_TIMEOUT设置为10s</span>
<span class="c"># GRUB_TIMEOUT_STYLE=hidden</span>
<span class="nv">GRUB_TIMEOUT</span><span class="o">=</span>10
</code></pre></div></div> <p>接着使更改生效</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>update-grub
</code></pre></div></div> <p>重启，ubuntu选择界面中选择新安装的内核启动，查看当前内核版本</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">uname</span> <span class="nt">-a</span>
</code></pre></div></div> <p>查看 kvm 和 kvm_intel 两个模块是否加载</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lsmod |grep kvm
<span class="c"># 如果没有就手动加载</span>
modprobe kvm
modprobe kvm_intel
</code></pre></div></div> <p>检查 <code class="language-plaintext highlighter-rouge">/dev/kvm</code> 文件，该文件是 KVM 内核模块提供给用户空间的 qemu-kvm 程序使用的一个控制接口</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">ls</span> <span class="nt">-l</span> /dev/kvm
</code></pre></div></div> <h3 id="单独编译-kvm-模块">单独编译 KVM 模块</h3> <p>进入 Linux 源码目录，执行以下命令单独编译 KVM 模块</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make <span class="nt">-j8</span> <span class="nt">-C</span> <span class="sb">`</span><span class="nb">pwd</span><span class="sb">`</span> <span class="nv">M</span><span class="o">=</span><span class="sb">`</span><span class="nb">pwd</span><span class="sb">`</span>/arch/x86/kvm
rmmod kvm-intel
rmmod kvm
insmod <span class="nb">arch</span>/x86/kvm/kvm.ko
insmod <span class="nb">arch</span>/x86/kvm/kvm-intel.ko
</code></pre></div></div> <h2 id="源码编译安装-qemu">源码编译安装 QEMU</h2> <ul> <li><a href="https://download.qemu.org/qemu-4.0.0.tar.xz">官网下载源码qemu-4.0.0.tar.xz</a></li> </ul> <h3 id="配置-qemu">配置 QEMU</h3> <p>安装依赖库</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt <span class="nb">install </span>libglib2.0-dev libpixman-1-dev
</code></pre></div></div> <p>创建 build 目录并配置支持 KVM 选项、目标架构名以及调试选项</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir </span>build
<span class="nb">cd </span>build
../configure <span class="nt">--enable-kvm</span> <span class="nt">--target-list</span><span class="o">=</span>x86_64-softmmu <span class="nt">--enable-debug</span>
</code></pre></div></div> <p>完成之后查看输出确保配置正确：</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>VNC support <span class="nb">yes</span> <span class="c"># 通常需要通过 VNC 连接到客户机中</span>
KVM support <span class="nb">yes</span> <span class="c"># 这是对 KVM 的支持</span>
</code></pre></div></div> <h3 id="编译安装-qemu">编译安装 QEMU</h3> <p>编译 QEMU， <code class="language-plaintext highlighter-rouge">make</code> 完成之后在 <code class="language-plaintext highlighter-rouge">build/x86_64-softmmu/</code> 目录下生成了可执行文件 <code class="language-plaintext highlighter-rouge">qemu-system-x86_64</code> 。执行 <code class="language-plaintext highlighter-rouge">make install</code> 将 QEMU 安装到 host 系统环境中。</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make <span class="nt">-j8</span>
make <span class="nb">install</span>
</code></pre></div></div> <p>检查安装之后的系统状态</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>which qemu-system-x86_64
which qemu-img
</code></pre></div></div> <p>QEMU 是用户态的程序，不需要重启系统，直接用 <code class="language-plaintext highlighter-rouge">qemu-systemx86_64</code> 命令行工具即可启动虚拟机。</p> <h1 id="实验二创建并启动虚拟机">实验二：创建并启动虚拟机</h1> <h2 id="下载镜像">下载镜像</h2> <ul> <li>首先下载一个供虚拟机运行的镜像（本实例为 ubuntu.iso，读者可自行选择其他iso），并切换到存放镜像的路径下</li> </ul> <h2 id="创建磁盘文件">创建磁盘文件</h2> <ul> <li> <p>创建一个空的镜像文件来存储虚拟机的系统和文件（也可采用 <code class="language-plaintext highlighter-rouge">qemu-img</code> 命令）</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">dd </span><span class="k">if</span><span class="o">=</span>/dev/zero <span class="nv">of</span><span class="o">=</span>guest.img <span class="nv">bs</span><span class="o">=</span>1M <span class="nv">count</span><span class="o">=</span>40960
</code></pre></div> </div> <p><code class="language-plaintext highlighter-rouge">dd</code> 命令用于生成虚拟块设备文件。<code class="language-plaintext highlighter-rouge">if</code> 参数告诉 <code class="language-plaintext highlighter-rouge">dd</code> 从哪个文件读取数据， <code class="language-plaintext highlighter-rouge">of</code> 参数表示读出的数据写入哪个文件中。 <code class="language-plaintext highlighter-rouge">/dev/zero</code> 是 Linux 提供的一个特殊的字符设备，其每次读取的结果都是二进制0，可用于生成空镜像文件。<code class="language-plaintext highlighter-rouge">bs=1M</code> 表示每一次读写1M数据，<code class="language-plaintext highlighter-rouge">count=40960</code>表示读写 40960 次，这样就指定了生成文件的大小为40G。</p> </li> </ul> <h2 id="启动虚拟机">启动虚拟机</h2> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>qemu-system-x86_64 <span class="nt">-cpu</span> host <span class="nt">-smp</span> 1 <span class="nt">-m</span> 2048 <span class="nt">--enable-kvm</span> guest.img <span class="nt">-cdrom</span> ubuntu.iso
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">-cpu</code> 参数用于指定cpu类型和型号， <code class="language-plaintext highlighter-rouge">-smp</code> 参数用于cpu核数， <code class="language-plaintext highlighter-rouge">-m</code> 参数用于指定内存大小，<code class="language-plaintext highlighter-rouge">-cdrom</code> 参数用于指定要载入的镜像。</p> <h2 id="安装-gvncviewer-并连接虚拟机">安装 gvncviewer 并连接虚拟机</h2> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt <span class="nb">install </span>gvncviewer
gvncviewer 127.0.0.1::5900 <span class="c"># 默认情况 QEMU 开启5900端口</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">Ctrl+Alt+2</code> 切换到 QEMU 监视器窗口，可以执行 <code class="language-plaintext highlighter-rouge">info kvm</code> 命令来查看当前 QEMU 是否使用 KVM。<code class="language-plaintext highlighter-rouge">Ctrl+Alt+1</code> 切换回原窗口。</p>]]></content><author><name></name></author><category term="配套实验"/><category term="QEMU"/><category term="KVM"/><summary type="html"><![CDATA[这篇文章主要介绍了如何搭建KVM虚拟化平台，包括安装Ubuntu Host系统、编译安装Linux内核、配置KVM支持、编译安装QEMU，以及如何创建和启动虚拟机。]]></summary></entry><entry><title type="html">第二章实验</title><link href="https://dams.net.cn/book/2025/lab2/" rel="alternate" type="text/html" title="第二章实验"/><published>2025-04-01T08:00:00+00:00</published><updated>2025-04-01T08:00:00+00:00</updated><id>https://dams.net.cn/book/2025/lab2</id><content type="html" xml:base="https://dams.net.cn/book/2025/lab2/"><![CDATA[<h1 id="实验一简易kvm虚拟机实例">实验一：简易KVM虚拟机实例</h1> <h2 id="背景知识">背景知识</h2> <p><strong><code class="language-plaintext highlighter-rouge">/dev/kvm</code> 设备</strong></p> <p><code class="language-plaintext highlighter-rouge">/dev/kvm</code> 是一个字符设备，KVM 通过该设备导出了一系列 ioctl 系统调用接口，QEMU 等用户层程序通过这些接口来控制虚拟机。KVM 的 ioctl 接口可以分为三类：</p> <ol> <li>系统全局的 ioctl，这类 ioctl 的作用对象是 KVM 模块，对应内核处理函数入口为 <code class="language-plaintext highlighter-rouge">kvm_dev_ioctl</code>，功能包括获取 KVM 版本，创建 VM 等。</li> <li>虚拟机相关的 ioctl，这类 ioctl 的作用对象是 VM，对应内核处理函数入口为 <code class="language-plaintext highlighter-rouge">kvm_vm_ioctl</code> ，功能包括设置 VM 内存，创建 VCPU 等。</li> <li>虚拟机 VCPU 相关的 ioctl，这类 ioctl 的作用对象是 VCPU，对应内核处理函数入口为 <code class="language-plaintext highlighter-rouge">kvm_vcpu_ioctl</code> ，功能包括设置寄存器，VCPU运行等。</li> </ol> <h2 id="解决思路">解决思路</h2> <p>创建一个简易 KVM 虚拟机实例分为两大部分：</p> <ol> <li>实现一个简易的用户层 QEMU。</li> <li>实现一个简易的 guest 内核。</li> </ol> <h3 id="实现简易的用户层-qemu">实现简易的用户层 QEMU</h3> <p>本书的1.4.1章节中介绍了 KVM 虚拟机与 QEMU 的关系： KVM 的生命周期由 QEMU 管理和维护，一个 KVM 虚拟机可以理解为一个 QEMU 进程，虚拟机的一个 VCPU 对应 QEMU 进程中的一个线程。</p> <p>KVM 导出了一系列 IOCTL 接口供用户层创建、配置、启动虚拟机，典型的用户层软件是 QEMU ，但是从本质上来说，QEMU 和 KVM 可以不必相互依赖，本实验展示简易的用户层程序（后称为简易 QEMU）。</p> <p>该简易 QEMU 主要实现如下几个功能：</p> <ul> <li>创建虚拟机对象</li> <li>为虚拟机分配物理内存、加载 guest 二进制</li> <li>创建虚拟机 VCPU 对象</li> <li>设置 VCPU 的相关寄存器、将 VCPU 调度到物理 CPU 上运行</li> <li>处理 VM Exit 事件</li> </ul> <p><strong>创建虚拟机对象</strong></p> <p>首先打开 <code class="language-plaintext highlighter-rouge">/dev/kvm</code> 设备获取 KVM 模块的文件描述符 <code class="language-plaintext highlighter-rouge">dev_fd</code> ，通过 ioctl(KVM_GET_API_VERSION) 获取 KVM 的版本号，从而使用户层知道相关接口在内核是否有支持。</p> <p>再通过 ioctl(KVM_CREATE_VM) 创建一个虚拟机对象，该 ioctl 返回一个代表虚拟机的文件描述符 <code class="language-plaintext highlighter-rouge">vm_fd</code> ，之后可以通过 <code class="language-plaintext highlighter-rouge">vm_fd</code> 控制虚拟机的内存、VCPU 等。</p> <p><strong>为虚拟机分配物理内存、加载 guest 二进制</strong></p> <p>虚拟机的物理内存对应 QEMU 的进程地址空间，使用 <code class="language-plaintext highlighter-rouge">mmap</code> 分配一定大小的内存作为虚拟机物理内存，然后调用 ioctl(KVM_SET_USER_MEMORY_REGION) 为虚拟机指定一个内存条。接着将简易的 guest 二进制加载到该内存区域。</p> <p><strong>创建虚拟机 VCPU 对象</strong></p> <p>调用 ioctl(KVM_CREATE_VCPU) 创建虚拟机 VCPU 对象，该 ioctl 返回一个代表 VCPU 的文件描述符 <code class="language-plaintext highlighter-rouge">vcpu_fd</code> ，之后通过 <code class="language-plaintext highlighter-rouge">vcpu_fd</code> 控制虚拟机的运行等。</p> <p>虚拟机运行过程中用户层（简易QEMU）和内核层（KVM模块）之间的数据共享是通过 VCPU 维护的 <code class="language-plaintext highlighter-rouge">kvm_run</code> 数据结构来实现的。首先通过调用 ioctl(KVM_GET_VCPU_MMAP_SIZE) 得到该结构的大小，接着调用 <code class="language-plaintext highlighter-rouge">mmap</code> 为 <code class="language-plaintext highlighter-rouge">kvm_run</code> 分配空间。</p> <p><strong>设置 VCPU 的相关寄存器、将 VCPU 调度到物理 CPU 上运行</strong></p> <p>为了让虚拟机 VCPU 运行起来，需要设置 VCPU 的相关寄存器，其中段寄存器和控制寄存器等特殊寄存器存放在 <code class="language-plaintext highlighter-rouge">kvm_sregs</code> 中，通过 ioctl(KVM_GET_SREGS)、ioctl(KVM_SET_SREGS) 读取和修改，通用寄存器存放在 <code class="language-plaintext highlighter-rouge">kvm_regs</code> 中，通过 ioctl(KVM_SET_REGS) 修改。</p> <p>准备工作完毕，可以让虚拟机运行起来了，通常在一个死循环中对 <code class="language-plaintext highlighter-rouge">vcpu_fd</code> 调用 ioctl(KVM_RUN)。KVM 内核模块在处理这个 ioctl 时会把 VCPU 调度到物理 CPU 上运行，遇到 KVM 无法处理的退出事件则会返回到此处，处理完之后再次进入循环调用 ioctl(KVM_RUN) 进入虚拟机。</p> <p><strong>处理 VM Exit 事件</strong></p> <p>内核 KVM 无法处理时，会将信息保存到 <code class="language-plaintext highlighter-rouge">kvm_run</code> 并 return 0，用户层则可以通过读取该共享内存得知虚拟机退出原因，进行相应的处理。本例包括 guest 向 I/O 端口写数据产生的 <code class="language-plaintext highlighter-rouge">KVM_EXIT_IO</code> 退出的处理、执行 HALT 指令等。</p> <h3 id="实现简易的-guest-内核">实现简易的 guest 内核</h3> <p>简易内核主要实现一些能触发 VM Exit 的操作，包括向 I/O 端口写数据、执行 HALT 指令。汇编文件如下</p> <pre><code class="language-assembly">// guest_test.S

.globl _start
    .code16
_start:
    xorw %ax, %ax

    out %ax, $0x10
    inc %ax
    out %ax, $0x10
    inc %ax
    out %ax, $0x10

    hlt
</code></pre> <p>编译</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>as <span class="nt">-32</span> guest_test.S <span class="nt">-o</span> guest_test.o
<span class="nv">$ </span>ld <span class="nt">-m</span> elf_i386 <span class="nt">--oformat</span> binary <span class="nt">-e</span> _start <span class="nt">-Ttext</span> 0x0 <span class="nt">-o</span> guest_test.bin guest_test.o
</code></pre></div></div> <p>相关链接参数说明：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-m EMULATION                Set emulation
-e ADDRESS, --entry ADDRESS Set start address
--oformat TARGET            Specify target of output file
-Ttext ADDRESS              Set address of .text section
-o FILE, --output FILE      Set output file name
</code></pre></div></div> <h2 id="编译执行">编译执行</h2> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>make
as <span class="nt">-32</span> guest_test.S <span class="nt">-o</span> guest_test.o
ld <span class="nt">-m</span> elf_i386 <span class="nt">--oformat</span> binary <span class="nt">-e</span> _start <span class="nt">-Ttext</span> 0x0 <span class="nt">-o</span> guest_test.bin guest_test.o

<span class="nv">$ </span><span class="nb">ls
</span>guest_test.bin  guest_test.S  qemu_sample    qemu_sample.o
guest_test.o    Makefile      qemu_sample.c

<span class="nv">$ </span>./qemu_sample
open /dev/kvm...
get vm fd...
load guest_test.bin...
get vcpu fd...
<span class="nb">set </span>vcpu regs...
vcpu run...
KVM_EXIT_IO
guest put io data: 0
vcpu run...
KVM_EXIT_IO
guest put io data: 1
vcpu run...
KVM_EXIT_IO
guest put io data: 2
vcpu run...
KVM_EXIT_HLT

</code></pre></div></div> <h1 id="实验二捕获虚拟机下一条指令地址信息">实验二：捕获虚拟机下一条指令地址信息</h1> <h2 id="背景知识-1">背景知识</h2> <p>下一条指令信息，存放在虚拟机的 CS：RIP 中，需要使用VMX系列指令读取VMCS相关字段</p> <h2 id="解决思路-1">解决思路</h2> <p>内核中封装了一些 vmcs 读取相关的函数：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp"># linux-5.15/arch/x86/kvm/vmx/vmx_ops.h
</span>
<span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">__vmcs_readl</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">field</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">value</span><span class="p">;</span>

	<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">"1: vmread %2, %1</span><span class="se">\n\t</span><span class="s">"</span>
		     <span class="s">".byte 0x3e</span><span class="se">\n\t</span><span class="s">"</span> <span class="cm">/* branch taken hint */</span>
		     <span class="s">"ja 3f</span><span class="se">\n\t</span><span class="s">"</span>

		     <span class="cm">/*
		      * VMREAD failed.  Push '0' for @fault, push the failing
		      * @field, and bounce through the trampoline to preserve
		      * volatile registers.
		      */</span>
		     <span class="s">"push $0</span><span class="se">\n\t</span><span class="s">"</span>
		     <span class="s">"push %2</span><span class="se">\n\t</span><span class="s">"</span>
		     <span class="s">"2:call vmread_error_trampoline</span><span class="se">\n\t</span><span class="s">"</span>

		     <span class="cm">/*
		      * Unwind the stack.  Note, the trampoline zeros out the
		      * memory for @fault so that the result is '0' on error.
		      */</span>
		     <span class="s">"pop %2</span><span class="se">\n\t</span><span class="s">"</span>
		     <span class="s">"pop %1</span><span class="se">\n\t</span><span class="s">"</span>
		     <span class="s">"3:</span><span class="se">\n\t</span><span class="s">"</span>

		     <span class="cm">/* VMREAD faulted.  As above, except push '1' for @fault. */</span>
		     <span class="s">".pushsection .fixup, </span><span class="se">\"</span><span class="s">ax</span><span class="se">\"\n\t</span><span class="s">"</span>
		     <span class="s">"4: push $1</span><span class="se">\n\t</span><span class="s">"</span>
		     <span class="s">"push %2</span><span class="se">\n\t</span><span class="s">"</span>
		     <span class="s">"jmp 2b</span><span class="se">\n\t</span><span class="s">"</span>
		     <span class="s">".popsection</span><span class="se">\n\t</span><span class="s">"</span>
		     <span class="n">_ASM_EXTABLE</span><span class="p">(</span><span class="mi">1</span><span class="n">b</span><span class="p">,</span> <span class="mi">4</span><span class="n">b</span><span class="p">)</span>
		     <span class="o">:</span> <span class="n">ASM_CALL_CONSTRAINT</span><span class="p">,</span> <span class="s">"=r"</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">:</span> <span class="s">"r"</span><span class="p">(</span><span class="n">field</span><span class="p">)</span> <span class="o">:</span> <span class="s">"cc"</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__always_inline</span> <span class="n">u16</span> <span class="nf">vmcs_read16</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">field</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vmcs_check16</span><span class="p">(</span><span class="n">field</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">static_branch_unlikely</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enable_evmcs</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">evmcs_read16</span><span class="p">(</span><span class="n">field</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">__vmcs_readl</span><span class="p">(</span><span class="n">field</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">vmcs_readl</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">field</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vmcs_checkl</span><span class="p">(</span><span class="n">field</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">static_branch_unlikely</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enable_evmcs</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">evmcs_read64</span><span class="p">(</span><span class="n">field</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">__vmcs_readl</span><span class="p">(</span><span class="n">field</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>在 VM Exit 后，guest 相关信息会保存到 VMCS 字段，KVM 在 <code class="language-plaintext highlighter-rouge">vmx_handle_exit</code> 函数根据退出原因进行处理，处理完成后，再次返回虚拟机之前（VMENTRY/VMRESUME），下一条指令的地址信息保存VMCS中Guest相关字段中，在此可以查看虚拟机 CS：RIP 信息。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp"># linux-5.15/arch/x86/kvm/vmx/vmx.c
</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vmx_handle_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">fastpath_t</span> <span class="n">exit_fastpath</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">__vmx_handle_exit</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">exit_fastpath</span><span class="p">);</span>

    <span class="c1">// 获取当前VMCS的guest_rip和guest_cs字段</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">"GUEST CS:RIP=%04x:0x%016lx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
	       <span class="n">vmcs_read16</span><span class="p">(</span><span class="n">GUEST_CS_SELECTOR</span><span class="p">),</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">GUEST_RIP</span><span class="p">));</span>
	<span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="输出结果">输出结果</h2> <p>在linux目录下应用patch，运行编译脚本文件，dmesg查看输出。</p> <p>通过 <code class="language-plaintext highlighter-rouge">dmesg</code> 查看内核输出信息如下</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>dmesg
<span class="o">[</span>1476092.242576] GUEST CS:RIP<span class="o">=</span>0010:0xffffffffb768dc17
<span class="o">[</span>1476092.242579] GUEST CS:RIP<span class="o">=</span>0010:0xffffffffb768dc17
<span class="o">[</span>1476092.242581] GUEST CS:RIP<span class="o">=</span>0033:0x00005568d139af28
<span class="o">[</span>1476092.242582] GUEST CS:RIP<span class="o">=</span>0033:0x00005568d139af28
<span class="o">[</span>1476092.242584] GUEST CS:RIP<span class="o">=</span>0010:0xffffffffb768dc17
<span class="o">[</span>1476092.242587] GUEST CS:RIP<span class="o">=</span>0033:0x00005568d139af28
<span class="o">[</span>1476092.242597] GUEST CS:RIP<span class="o">=</span>0010:0xffffffffb768dc17
<span class="o">[</span>1476092.242602] GUEST CS:RIP<span class="o">=</span>0010:0xffffffffb768dc17
<span class="o">[</span>1476092.242606] GUEST CS:RIP<span class="o">=</span>0010:0xffffffffb768dc17
<span class="o">[</span>1476092.242611] GUEST CS:RIP<span class="o">=</span>0010:0xffffffffb768dc17
<span class="o">[</span>1476092.242616] GUEST CS:RIP<span class="o">=</span>0033:0x00005568d13ee0b5
<span class="o">[</span>1476092.242641] GUEST CS:RIP<span class="o">=</span>0010:0xffffffffb768dc17
<span class="o">[</span>1476092.242644] GUEST CS:RIP<span class="o">=</span>0033:0x00005568d13fa710
<span class="o">[</span>1476092.242647] GUEST CS:RIP<span class="o">=</span>0010:0xffffffffb768dc17
<span class="o">[</span>1476092.242651] GUEST CS:RIP<span class="o">=</span>0010:0xffffffffb768dc17
<span class="o">[</span>1476092.242680] GUEST CS:RIP<span class="o">=</span>0010:0xffffffffb768dc17
<span class="o">[</span>1476092.242684] GUEST CS:RIP<span class="o">=</span>0010:0xffffffffb768dc17
</code></pre></div></div> <h1 id="实验三伪造虚拟机-cpuid-信息">实验三：伪造虚拟机 CPUID 信息</h1> <h2 id="背景知识-2">背景知识</h2> <p>CPUID 指令</p> <ul> <li>CPUID 指令主要用来获取处理器的 identification 和 feature 信息，输入参数通过 EAX、ECX 寄存器传入，输出的值返回到 EAX、EBX、ECX、EDX 寄存器。</li> </ul> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/book/chapter2/exp3/CPUID-desc-480.webp 480w,/assets/img/book/chapter2/exp3/CPUID-desc-800.webp 800w,/assets/img/book/chapter2/exp3/CPUID-desc-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/book/chapter2/exp3/CPUID-desc.png" class="img-fluid rounded z-depth-1" width="70%" height="auto" title="CPUID-desc" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <ul> <li>指令操作码及相应字段含义详细参考 <a href="https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-2a-manual.pdf">Intel 手册 vol 2a</a></li> </ul> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/book/chapter2/exp3/ia-32-480.webp 480w,/assets/img/book/chapter2/exp3/ia-32-800.webp 800w,/assets/img/book/chapter2/exp3/ia-32-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/book/chapter2/exp3/ia-32.png" class="img-fluid rounded z-depth-1" width="70%" height="auto" title="ia-32" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h2 id="解决思路-2">解决思路</h2> <p>在 guest 中查看 CPU 相关信息：</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/book/chapter2/exp3/CPUinfo-guest-480.webp 480w,/assets/img/book/chapter2/exp3/CPUinfo-guest-800.webp 800w,/assets/img/book/chapter2/exp3/CPUinfo-guest-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/book/chapter2/exp3/CPUinfo-guest.png" class="img-fluid rounded z-depth-1" width="70%" height="auto" title="CPUinfo-guest" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>CPUID 指令的模拟在 <code class="language-plaintext highlighter-rouge">kvm_emulate_cpuid</code> 函数，首先从eax、ecx寄存器读取指令操作码等，然后调用 <code class="language-plaintext highlighter-rouge">kvm_cpuid</code> 遍历 <code class="language-plaintext highlighter-rouge">vcpu-&gt;arch.cpuid_entries</code> 表找出与本操作码对应的 entry，然后将 entry 中四个寄存器eax、ebx、ecx、edx的值读出。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp"># linux-5.15/arch/x86/kvm/cpuid.c
</span>
<span class="n">bool</span> <span class="nf">kvm_cpuid</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">eax</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">ebx</span><span class="p">,</span>
	       <span class="n">u32</span> <span class="o">*</span><span class="n">ecx</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">edx</span><span class="p">,</span> <span class="n">bool</span> <span class="n">exact_only</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">orig_function</span> <span class="o">=</span> <span class="o">*</span><span class="n">eax</span><span class="p">,</span> <span class="n">function</span> <span class="o">=</span> <span class="o">*</span><span class="n">eax</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="o">*</span><span class="n">ecx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_cpuid_entry2</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">exact</span><span class="p">,</span> <span class="n">used_max_basic</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">kvm_find_cpuid_entry</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
	<span class="n">exact</span> <span class="o">=</span> <span class="o">!!</span><span class="n">entry</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">exact_only</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">get_out_of_range_cpuid_entry</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">function</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
		<span class="n">used_max_basic</span> <span class="o">=</span> <span class="o">!!</span><span class="n">entry</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">eax</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">eax</span><span class="p">;</span>
		<span class="o">*</span><span class="n">ebx</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">ebx</span><span class="p">;</span>
		<span class="o">*</span><span class="n">ecx</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">ecx</span><span class="p">;</span>
		<span class="o">*</span><span class="n">edx</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">edx</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">function</span> <span class="o">==</span> <span class="mi">7</span> <span class="o">&amp;&amp;</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u64</span> <span class="n">data</span><span class="p">;</span>
		        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__kvm_get_msr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">MSR_IA32_TSX_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="nb">true</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">TSX_CTRL_CPUID_CLEAR</span><span class="p">))</span>
				<span class="o">*</span><span class="n">ebx</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">F</span><span class="p">(</span><span class="n">RTM</span><span class="p">)</span> <span class="o">|</span> <span class="n">F</span><span class="p">(</span><span class="n">HLE</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">eax</span> <span class="o">=</span> <span class="o">*</span><span class="n">ebx</span> <span class="o">=</span> <span class="o">*</span><span class="n">ecx</span> <span class="o">=</span> <span class="o">*</span><span class="n">edx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/*
		 * When leaf 0BH or 1FH is defined, CL is pass-through
		 * and EDX is always the x2APIC ID, even for undefined
		 * subleaves. Index 1 will exist iff the leaf is
		 * implemented, so we pass through CL iff leaf 1
		 * exists. EDX can be copied from any existing index.
		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">function</span> <span class="o">==</span> <span class="mh">0xb</span> <span class="o">||</span> <span class="n">function</span> <span class="o">==</span> <span class="mh">0x1f</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">entry</span> <span class="o">=</span> <span class="n">kvm_find_cpuid_entry</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">ecx</span> <span class="o">=</span> <span class="n">index</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
				<span class="o">*</span><span class="n">edx</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">edx</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">trace_kvm_cpuid</span><span class="p">(</span><span class="n">orig_function</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="o">*</span><span class="n">eax</span><span class="p">,</span> <span class="o">*</span><span class="n">ebx</span><span class="p">,</span> <span class="o">*</span><span class="n">ecx</span><span class="p">,</span> <span class="o">*</span><span class="n">edx</span><span class="p">,</span> <span class="n">exact</span><span class="p">,</span>
			<span class="n">used_max_basic</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">exact</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_emulate_cpuid</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">eax</span><span class="p">,</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">edx</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpuid_fault_enabled</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">kvm_require_cpl</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">eax</span> <span class="o">=</span> <span class="n">kvm_rax_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">ecx</span> <span class="o">=</span> <span class="n">kvm_rcx_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">kvm_cpuid</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eax</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ebx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ecx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">edx</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="n">kvm_rax_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">eax</span><span class="p">);</span>
	<span class="n">kvm_rbx_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">ebx</span><span class="p">);</span>
	<span class="n">kvm_rcx_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">ecx</span><span class="p">);</span>
	<span class="n">kvm_rdx_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">edx</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">kvm_skip_emulated_instruction</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>其中 <strong><code class="language-plaintext highlighter-rouge">vcpu-&gt;arch.cpuid_entries</code> 表的设置</strong>：该entries是一个结构数组，由qemu和kvm共同维护，qemu在 <code class="language-plaintext highlighter-rouge">kvm_arch_init_vcpu</code> 函数中设置完 entries 的值之后，调用 <code class="language-plaintext highlighter-rouge">kvm_vcpu_ioctl(cs, KVM_SET_CPUID2, &amp;cpuid_data)</code> 进入kvm，kvm中 <code class="language-plaintext highlighter-rouge">kvm_vcpu_ioctl_set_cpuid2</code> 函数再进一步设置。</p> <p>本实验<strong>以“model name”项</strong>为例进行测试，根据 Intel 手册该项对应的 CPUID 指令的操作码为 0x80000002～0x80000004，在 <code class="language-plaintext highlighter-rouge">kvm_cpuid</code> 中进行操作码匹配，对相应的寄存器进行修改。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">bool</span> <span class="nf">kvm_cpuid</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">eax</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">ebx</span><span class="p">,</span>
	       <span class="n">u32</span> <span class="o">*</span><span class="n">ecx</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">edx</span><span class="p">,</span> <span class="n">bool</span> <span class="n">exact_only</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">orig_function</span> <span class="o">=</span> <span class="o">*</span><span class="n">eax</span><span class="p">,</span> <span class="n">function</span> <span class="o">=</span> <span class="o">*</span><span class="n">eax</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="o">*</span><span class="n">ecx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_cpuid_entry2</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">exact</span><span class="p">,</span> <span class="n">used_max_basic</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/*set model_id fake value*/</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">model_id</span> <span class="o">=</span> <span class="s">"modify cpuid-model for test"</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cpuid_model</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">model_id</span><span class="p">);</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">cpuid_model</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">48</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">48</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">c</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">model_id</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="n">cpuid_model</span><span class="p">[</span><span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">]</span> <span class="o">|=</span> <span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">8</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">));</span>
    <span class="p">}</span>
	<span class="cm">/*set cpuid_model fake value*/</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">kvm_find_cpuid_entry</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
	<span class="n">exact</span> <span class="o">=</span> <span class="o">!!</span><span class="n">entry</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">exact_only</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">get_out_of_range_cpuid_entry</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">function</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
		<span class="n">used_max_basic</span> <span class="o">=</span> <span class="o">!!</span><span class="n">entry</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">eax</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">eax</span><span class="p">;</span>
		<span class="o">*</span><span class="n">ebx</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">ebx</span><span class="p">;</span>
		<span class="o">*</span><span class="n">ecx</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">ecx</span><span class="p">;</span>
		<span class="o">*</span><span class="n">edx</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">edx</span><span class="p">;</span>

		<span class="cm">/*****case model-id modify test*/</span>
		<span class="k">if</span><span class="p">(</span><span class="n">function</span> <span class="o">==</span> <span class="mh">0x80000002</span> <span class="o">||</span> <span class="n">function</span> <span class="o">==</span> <span class="mh">0x80000003</span> <span class="o">||</span> <span class="n">function</span> <span class="o">==</span> <span class="mh">0x80000004</span><span class="p">){</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">"index:0x%x, cpuid_model=0x%x"</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">cpuid_model</span><span class="p">[(</span><span class="n">function</span> <span class="o">-</span> <span class="mh">0x80000002</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">0</span><span class="p">]);</span>
			<span class="o">*</span><span class="n">eax</span> <span class="o">=</span> <span class="n">cpuid_model</span><span class="p">[(</span><span class="n">function</span> <span class="o">-</span> <span class="mh">0x80000002</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">0</span><span class="p">];</span>
			<span class="o">*</span><span class="n">ebx</span> <span class="o">=</span> <span class="n">cpuid_model</span><span class="p">[(</span><span class="n">function</span> <span class="o">-</span> <span class="mh">0x80000002</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
			<span class="o">*</span><span class="n">ecx</span> <span class="o">=</span> <span class="n">cpuid_model</span><span class="p">[(</span><span class="n">function</span> <span class="o">-</span> <span class="mh">0x80000002</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span>
			<span class="o">*</span><span class="n">edx</span> <span class="o">=</span> <span class="n">cpuid_model</span><span class="p">[(</span><span class="n">function</span> <span class="o">-</span> <span class="mh">0x80000002</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">3</span><span class="p">];</span>
		<span class="p">}</span>
		<span class="cm">/*****case model-id modify test*/</span>
		<span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div> <p>编译运行结果如下:</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/book/chapter2/exp3/modify-cpuid-model-test-480.webp 480w,/assets/img/book/chapter2/exp3/modify-cpuid-model-test-800.webp 800w,/assets/img/book/chapter2/exp3/modify-cpuid-model-test-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/book/chapter2/exp3/modify-cpuid-model-test.png" class="img-fluid rounded z-depth-1" width="70%" height="auto" title="modify-cpuid-model-test" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure>]]></content><author><name></name></author><category term="配套实验"/><category term="QEMU"/><category term="KVM"/><summary type="html"><![CDATA[这篇文章主要介绍了三个KVM虚拟化实验：实现一个简易的KVM虚拟机实例、捕获虚拟机下一条指令地址信息、伪造虚拟机CPUID信息。]]></summary></entry><entry><title type="html">第三章实验</title><link href="https://dams.net.cn/book/2025/lab3/" rel="alternate" type="text/html" title="第三章实验"/><published>2025-04-01T08:00:00+00:00</published><updated>2025-04-01T08:00:00+00:00</updated><id>https://dams.net.cn/book/2025/lab3</id><content type="html" xml:base="https://dams.net.cn/book/2025/lab3/"><![CDATA[<h1 id="实验一ept页表副本的创建与替换">实验一：EPT页表副本的创建与替换</h1> <p><strong>创建EPT页表副本，在虚拟机从实模式跳转到保护模式时替换原有的EPT页表</strong></p> <h2 id="解决思路">解决思路</h2> <p>如3.3.3中提到的，<code class="language-plaintext highlighter-rouge">vmx_load_mmu_pgd</code>函数中完成了EPT页表的加载：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="n">enable_ept</span><span class="p">){</span>
    <span class="n">eptp</span> <span class="o">=</span> <span class="n">construct_eptp</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">root_hpa</span><span class="p">,</span> <span class="n">root_level</span><span class="p">);</span>
    <span class="n">vmcs_write64</span><span class="p">(</span><span class="n">EPT_POINTER</span><span class="p">,</span> <span class="n">eptp</span><span class="p">);</span>
    <span class="p">......</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">vmx_load_mmu_pgd</code>调用了<code class="language-plaintext highlighter-rouge">construct_eptp</code>，将其返回值（<code class="language-plaintext highlighter-rouge">eptp</code>）写入到 <strong>VMCS</strong> 的 <strong>EPT_POINTER</strong> 字段。</p> <p><code class="language-plaintext highlighter-rouge">construct_eptp</code>函数中仅仅是根据Intel手册中对于<strong>VMCS</strong>的<strong>EPT_POINTER</strong>字段的规定进行数据的“组装”，关键点在其参数<code class="language-plaintext highlighter-rouge">root_hpa</code>。<code class="language-plaintext highlighter-rouge">root_hpa</code>是<code class="language-plaintext highlighter-rouge">kvm_mmu_load_pgd</code>调用<code class="language-plaintext highlighter-rouge">vmx_load_mmu_pgd</code>时提供的参数：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">kvm_mmu_load_pgd</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">u64</span> <span class="n">root_hpa</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="o">-&gt;</span><span class="n">root_hpa</span><span class="p">;</span>
    <span class="p">...</span>
    <span class="n">static_call</span><span class="p">(</span><span class="n">kvm_x86_load_mmu_pgd</span><span class="p">)(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">root_hpa</span><span class="p">,</span>
                                     <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="o">-&gt;</span><span class="n">shadow_root_level</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>继续跟踪<code class="language-plaintext highlighter-rouge">vcpu-&gt;arch.mmu-&gt;root_hpa</code>的来源，<code class="language-plaintext highlighter-rouge">kvm_mmu_load</code>函数调用了<code class="language-plaintext highlighter-rouge">kvm_mmu_load_pgd</code>，<code class="language-plaintext highlighter-rouge">kvm_mmu_load</code>函数如下：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">kvm_mmu_load</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
    <span class="p">...</span>
    <span class="k">if</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="o">-&gt;</span><span class="n">direct_map</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">mmu_alloc_direct_roots</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

    <span class="p">...</span>
    <span class="n">kvm_mmu_load_pgd</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>采用了EPT的地址转换方案时，<code class="language-plaintext highlighter-rouge">vcpu-&gt;arch.mmu.direct_map</code>的值为<code class="language-plaintext highlighter-rouge">True</code>（可以参考本书的3.3.2节的<code class="language-plaintext highlighter-rouge">init_kvm_tdp_mmu</code>函数讲解），所以会进入<code class="language-plaintext highlighter-rouge">mmu_alloc_direct_roots(vcpu)</code>分支：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">mmu_alloc_direct_roots</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hpa_t</span> <span class="n">root</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">is_tdp_mmu_get_vcpu_root_hpa</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">)){</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">kvm_tdp_mmu_get_vcpu_root_hpa</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
        <span class="n">mmu</span><span class="o">-&gt;</span><span class="n">root_hpa</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div> <p>其调用了<code class="language-plaintext highlighter-rouge">kvm_tdp_mmu_get_vcpu_root_hpa</code>，该函数实现如下：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">hpa_t</span> <span class="nf">kvm_tdp_mmu_get_vcpu_root_hpa</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">kvm_mmu_page_role</span> <span class="n">role</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="o">*</span><span class="n">root_copy</span><span class="p">;</span>

	<span class="n">lockdep_assert_held_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>

	<span class="n">role</span> <span class="o">=</span> <span class="n">page_role_for_level</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="o">-&gt;</span><span class="n">shadow_root_level</span><span class="p">);</span>

	<span class="cm">/* Check for an existing root before allocating a new one. */</span>
	<span class="n">for_each_tdp_mmu_root</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">kvm_mmu_role_as_id</span><span class="p">(</span><span class="n">role</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">.</span><span class="n">word</span> <span class="o">==</span> <span class="n">role</span><span class="p">.</span><span class="n">word</span> <span class="o">&amp;&amp;</span>
		    <span class="n">kvm_tdp_mmu_get_root</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">root</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">root</span> <span class="o">=</span> <span class="n">alloc_tdp_mmu_page</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="o">-&gt;</span><span class="n">shadow_root_level</span><span class="p">);</span>
	<span class="n">refcount_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">tdp_mmu_root_count</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">tdp_mmu_pages_lock</span><span class="p">);</span>
	<span class="n">list_add_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">tdp_mmu_roots</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">tdp_mmu_pages_lock</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">__pa</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">spt</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>在没有找到已经存在的root的情况下会创建新的root，调用<code class="language-plaintext highlighter-rouge">alloc_tdp_mmu_page</code>，其具体实现在本书的3.3.4节进行过详细介绍。</p> <p>所以我们可以在<code class="language-plaintext highlighter-rouge">kvm_tdp_mmu_get_vcpu_root_hpa</code>中构造EPT副本的根目录。</p> <h2 id="实验">实验</h2> <ol> <li>在<code class="language-plaintext highlighter-rouge">struct kvm_vcpu</code>中添加一个成员变量<code class="language-plaintext highlighter-rouge">bool rebuild_ept</code>；</li> <li>在<code class="language-plaintext highlighter-rouge">kvm_set_cr0</code>中添加判断开启分页的语句，并将<code class="language-plaintext highlighter-rouge">rebuild_ept</code>设置为<code class="language-plaintext highlighter-rouge">true</code>；</li> <li>在<code class="language-plaintext highlighter-rouge">kvm_tdp_mmu_get_vcpu_root_hpa</code>中添加创建EPTP副本的代码，通过一个if语句控制，创建完成后将<code class="language-plaintext highlighter-rouge">rebuild_ept</code>设置为<code class="language-plaintext highlighter-rouge">false</code>。</li> </ol> <p><strong>实验结果</strong></p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dmesg
</code></pre></div></div> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/book/chapter3/exp1/1679042004764-480.webp 480w,/assets/img/book/chapter3/exp1/1679042004764-800.webp 800w,/assets/img/book/chapter3/exp1/1679042004764-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/book/chapter3/exp1/1679042004764.png" class="img-fluid rounded z-depth-1" width="70%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h1 id="实验二vmfunc的创建与使用">实验二：VMFUNC的创建与使用</h1> <p><strong>创建多个EPT页表，并使用EPTP机制对虚拟机线程进行页表隔离与切换</strong></p> <h2 id="背景知识">背景知识</h2> <p>开启VMFUNC功能需要：</p> <ol> <li>VM-Function的第0位置1，其余位为0；</li> <li>“activate secondary controls”VM-execution控制位（bit 31）置位1；</li> <li>“enable VM functions”VM-execution控制位（bit 13）置位1；</li> <li>指定EPTP list的地址；</li> <li>向EPTP List中填入适当的EPTP。</li> </ol> <h2 id="解决思路-1">解决思路</h2> <p>为了完成实验目标，主要需要以下步骤：</p> <p><strong>KVM端</strong>：</p> <ol> <li>开启VMFUNC支持；</li> <li>为EPTP List分配内存，在VMCS中写入EPTP List的地址</li> <li>创建EPTP页表副本，在EPTP List中写入地址</li> <li>在EPT violation中进行设置，检测到Non-root模式调用VMFUNC后，置换root_hpa指针</li> <li>在虚拟机退出时释放EPTP List所在页</li> <li>在卸载MMU时释放创建的页表副本。</li> </ol> <p><strong>虚拟机内</strong>：</p> <ol> <li>启动新的线程，在进程创建和退出时都调用VMFUNC</li> </ol> <h2 id="实验-1">实验</h2> <h3 id="开启vmfunc支持">开启VMFUNC支持</h3> <ul> <li>KVM中activate secondary control已经默认开启</li> <li>enable VM functions默认关闭</li> <li>VM-Function控制位未开启</li> </ul> <p>在<code class="language-plaintext highlighter-rouge">./arch/x86/kvm/vmx/vmx.c</code>中，修改<code class="language-plaintext highlighter-rouge">vmx_secondary_exec_control</code>函数：</p> <div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gi">+++ exec_control |= SECONDARY_EXEC_ENABLE_VMFUNC
</span></code></pre></div></div> <p>在<code class="language-plaintext highlighter-rouge">./arch/x86/kvm/vmx/vmx.c</code>中，修改<code class="language-plaintext highlighter-rouge">init_vmcs</code>函数：</p> <pre><code class="language-C">if (cpu_has_vmx_vmfunc()){
	printk("[init_vmcs]: secondary turn on\n");
	vmcs_write64(VM_FUNCTION_CONTROL, 1);//最低位置1
}
</code></pre> <h3 id="为eptp-list分配内存在vmcs中写入eptp-list的地址">为EPTP List分配内存，在VMCS中写入EPTP List的地址</h3> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">vmx_enable_ept_switching</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">eptp_list_pg</span><span class="p">;</span>

	<span class="n">eptp_list_pg</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">__GFP_ZERO</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">eptp_list_pg</span><span class="p">){</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">eptp_list_pg</span> <span class="o">=</span> <span class="n">eptp_list_pg</span><span class="p">;</span>

	<span class="n">vmcs_write64</span><span class="p">(</span><span class="n">EPTP_LIST_ADDRESS</span><span class="p">,</span> <span class="n">page_to_phys</span><span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">eptp_list_pg</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="在eptp-list中写入地址">在EPTP List中写入地址</h3> <p>在<code class="language-plaintext highlighter-rouge">vmx_load_mmu_pgd</code>中：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">if</span> <span class="p">(</span><span class="n">enable_ept</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">eptp</span> <span class="o">=</span> <span class="n">construct_eptp</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">root_hpa</span><span class="p">,</span> <span class="n">root_level</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">eptp_list_pg</span><span class="p">){</span>
			<span class="n">eptp_list</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="n">phys_to_virt</span><span class="p">(</span><span class="n">page_to_phys</span><span class="p">(</span><span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">eptp_list_pg</span><span class="p">));</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">EPTP_LIST_NUM</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
				<span class="n">eptp_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">eptp</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
</code></pre></div></div> <h3 id="创建页表副本">创建页表副本</h3> <p>在<code class="language-plaintext highlighter-rouge">struct kvm_mmu *mmu</code>中创建一个成员变量：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define KVM_EPTP_NUMBER 1//EPTP的数量按需设置
</span><span class="k">struct</span> <span class="n">kvm_mmu</span><span class="p">{</span>
    <span class="p">...</span>
    <span class="n">hpa_t</span> <span class="n">new_root_hpa</span><span class="p">[</span><span class="n">KVM_EPTP_NUMBERS</span><span class="p">];</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div> <p>然后为新的根分配内存，参考<code class="language-plaintext highlighter-rouge">kvm_tdp_mmu_get_vcpu_root_hpa</code>实现了<code class="language-plaintext highlighter-rouge">new_kvm_tdp_mmu_get_vcpu_root_hpa</code></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">mmu_alloc_direct_roots</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">){</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">is_tdp_mmu_enabled</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">root</span> <span class="o">=</span> <span class="n">kvm_tdp_mmu_get_vcpu_root_hpa</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="n">mmu</span><span class="o">-&gt;</span><span class="n">root_hpa</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">KVM_EPTP_NUMBERS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
			<span class="n">mmu</span><span class="o">-&gt;</span><span class="n">new_root_hpa</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_kvm_tdp_mmu_get_vcpu_root_hpa</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">hpa_t</span> <span class="nf">new_kvm_tdp_mmu_get_vcpu_root_hpa</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">){</span>
    <span class="k">union</span> <span class="n">kvm_mmu_page_role</span> <span class="n">role</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>

    <span class="n">lockdep_assert_held_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>

    <span class="n">role</span> <span class="o">=</span> <span class="n">alloc_tdp_mmu_kpage</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="o">-&gt;</span><span class="n">shadow_root_level</span><span class="p">);</span>
    <span class="n">refcount_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">tdp_mmu_root_count</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

    <span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">tdp_mmu_pages_lock</span><span class="p">);</span>
    <span class="n">list_add_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">tdp_mmu_roots</span><span class="p">);</span>
    <span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">tdp_mmu_pages_lock</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">__pa</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">spt</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>相比<code class="language-plaintext highlighter-rouge">kvm_tdp_mmu_get_vcpu_root_hpa</code>，<code class="language-plaintext highlighter-rouge">new_kvm_tdp_mmu_get_vcpu_root_hpa</code>删除了从备用链表中取出页表的链表，强制KVM分配新的物理页。</p> <p>在<code class="language-plaintext highlighter-rouge">vmx_load_mmu_pgd</code>中添加一个<strong>参数</strong>：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">vmx_load_mmu_pgd</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">hpa_t</span> <span class="n">root_hpa</span><span class="p">,</span> <span class="n">hpa_t</span> <span class="o">*</span><span class="n">new_root_hpa</span><span class="p">,</span> <span class="kt">int</span> <span class="n">root_level</span><span class="p">){</span>
<span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">enable_ept</span><span class="p">){</span>
        <span class="n">eptp</span> <span class="o">=</span> <span class="n">construct_eptp</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">root_hpa</span><span class="p">,</span> <span class="n">root_level</span><span class="p">);</span>
        <span class="n">vmcs_write64</span><span class="p">(</span><span class="n">EPT_POINTER</span><span class="p">,</span> <span class="n">eptp</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">eptp_list_pg</span><span class="p">){</span>
			<span class="n">eptp_list</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="n">phys_to_virt</span><span class="p">(</span><span class="n">page_to_phys</span><span class="p">(</span><span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">eptp_list_pg</span><span class="p">));</span>
			<span class="n">eptp_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">eptp</span><span class="p">;</span>

			<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">KVM_EPTP_NUMBERS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
				<span class="n">new_eptp</span> <span class="o">=</span> <span class="n">construct_eptp</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">new_root_hpa</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">root_level</span><span class="p">);</span>
				<span class="n">eptp_list</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_eptp</span><span class="p">;</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">"new_eptp: 0x%016llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">new_eptp</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
    <span class="p">}</span>
<span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div> <p>进而需要修改<code class="language-plaintext highlighter-rouge">kvm_mmu_load_pgd</code>：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">kvm_mmu_load_pgd</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">){</span>
<span class="p">...</span>
    <span class="n">new_root_hpa</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="o">-&gt;</span><span class="n">new_root_hpa</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">KVM_EPTP_NUMBERS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">VALID_PAGE</span><span class="p">(</span><span class="n">new_root_hpa</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">static_call</span><span class="p">(</span><span class="n">kvm_x86_load_mmu_pgd</span><span class="p">)(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">root_hpa</span><span class="p">,</span> <span class="n">new_root_hpa</span><span class="p">,</span>
 					  <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="o">-&gt;</span><span class="n">shadow_root_level</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>注意，由于KVM支持多种体系结构，所以需要同时修改AMD SVM相关函数的参数。</p> <h3 id="虚拟机内调用vmfunc">虚拟机内调用VMFUNC</h3> <p>编写应用程序代码，在虚拟机中运行</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="cp">#define VMX_FUNC ".byte 0x0f,0x01,0xd4" //硬编码VMFUNC的指令
</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmfunc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ept</span><span class="p">){</span>
    <span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span>
        <span class="n">VMX_FUNC</span>
        <span class="o">:</span>
        <span class="o">:</span> <span class="s">"a"</span><span class="p">(</span><span class="n">nr</span><span class="p">),</span> <span class="s">"c"</span><span class="p">(</span><span class="n">ept</span><span class="p">)</span>
        <span class="o">:</span> <span class="s">"memory"</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>启动一个线程：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="o">*</span><span class="nf">thread_func</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span> <span class="n">arg</span><span class="p">){</span>
    <span class="n">vmfunc</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">i</span><span class="o">++</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"i = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="n">vmfunc</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="处理ept-violation">处理EPT violation</h3> <p>切换VMFUNC后，执行指令会导致EPT Violation从而陷入到Hypervisor中。需要在Hypervisor中检查当前的EPTP指针，然后遍历<code class="language-plaintext highlighter-rouge">new_root_hpa</code>数组找到指针是否切换，如果指针进行了切换则需要修改页面的root_hpa，使得KVM能够利用EPT violation维护EPT页表。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">eptp</span> <span class="o">=</span> <span class="n">vmcs_read64</span><span class="p">(</span><span class="n">EPT_POINTER</span><span class="p">);</span>
	<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">KVM_EPTP_NUMBERS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
		<span class="k">if</span><span class="p">((</span><span class="n">eptp</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">==</span> <span class="p">((</span><span class="n">mmu</span><span class="o">-&gt;</span><span class="n">new_root_hpa</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)){</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">"[ept_violation]: new_root_hpa[%d] = 0x%llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">mmu</span><span class="o">-&gt;</span><span class="n">new_root_hpa</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">"[ept_violation]: root_hpa = 0x%llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">mmu</span><span class="o">-&gt;</span><span class="n">root_hpa</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">"[ept_violation]: Currenty eptp = 0x%llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">eptp</span><span class="p">);</span>
			<span class="c1">// exchange root_hpa and new_root_hpa[i]</span>
			<span class="n">temp</span> <span class="o">=</span> <span class="n">mmu</span><span class="o">-&gt;</span><span class="n">root_hpa</span><span class="p">;</span>
			<span class="n">mmu</span><span class="o">-&gt;</span><span class="n">root_hpa</span> <span class="o">=</span> <span class="n">mmu</span><span class="o">-&gt;</span><span class="n">new_root_hpa</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">mmu</span><span class="o">-&gt;</span><span class="n">new_root_hpa</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
</code></pre></div></div> <h3 id="结果">结果</h3> <p>能够成功输出：<code class="language-plaintext highlighter-rouge">i = 1</code></p> <p>查看内核debug信息：</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dmesg
</code></pre></div></div> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/book/chapter3/exp2/vmfunc_thread-480.webp 480w,/assets/img/book/chapter3/exp2/vmfunc_thread-800.webp 800w,/assets/img/book/chapter3/exp2/vmfunc_thread-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/book/chapter3/exp2/vmfunc_thread.png" class="img-fluid rounded z-depth-1" width="70%" height="auto" title="vmfunc_thread" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>此时ept_violation处理函数中输出此时的eptp指针为0x1c0f8c05e，正是新创建的eptp。</p> <h1 id="实验三气球模型的充气与放气实现">实验三：气球模型的充气与放气实现</h1> <p><strong>QEMU中增加捕获和修改气球模型的映射页面的功能，并在“放气”时将这些页面重新映射到虚拟机操作系统内核中。</strong></p> <h2 id="背景知识-1">背景知识</h2> <h3 id="使用qemu的balloon功能"><strong>使用QEMU的balloon功能</strong></h3> <ol> <li>正常通过KVM/QEMU启动虚拟机，可以参考实验一<a href="https://gitee.com/silver-zhou/virtualization_book/tree/v-1.0/第一章实验#创建并启动虚拟机">第一章实验</a></li> <li>通过VNC连接到QEMU</li> </ol> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gvncviewer 127.0.0.1::5900
</code></pre></div></div> <ol> <li>通过快捷键<code class="language-plaintext highlighter-rouge">Ctrl+Alt+2</code>切换到QEMU Monitor</li> <li>查看balloon设备信息</li> </ol> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>qemu<span class="o">)</span> info balloon
</code></pre></div></div> <ol> <li>修改虚拟机可用的内存</li> </ol> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>qemu<span class="o">)</span> balloon 2048
</code></pre></div></div> <ul> <li>注意数字单位是MB</li> </ul> <ol> <li>通过快捷键<code class="language-plaintext highlighter-rouge">Ctrl+Alt+2</code>返回到虚拟机图形界面</li> <li>在虚拟机中查看内存使用情况</li> </ol> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>free <span class="nt">-m</span>
</code></pre></div></div> <ol> <li>重复3-7步骤，将虚拟机可用内存修改为4096MB，再次查看内存使用情况</li> </ol> <h3 id="调试qemu"><strong>调试QEMU</strong></h3> <p>在进行QEMU代码修改的时候，可以通过调试的方法检查代码中出现的错误。</p> <ol> <li>确保在编译qemu时开启了debug选项</li> </ol> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./configure <span class="nt">--enable-debug</span>
</code></pre></div></div> <ol> <li>利用qemu启动虚拟机</li> </ol> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>qemu-system-x86_64 <span class="nt">-m</span> 4096 <span class="nt">-smp</span> 4 <span class="nt">--enable-kvm</span> ubuntu.img <span class="nt">-net</span> user,host<span class="o">=</span>10.0.2.10,hostfwd<span class="o">=</span>tcp::10021-:22,hostfwd<span class="o">=</span>tcp::10025-:80 <span class="nt">-net</span> nic <span class="nt">-device</span> virtio-balloon-pci,id<span class="o">=</span>balloon0,bus<span class="o">=</span>pci.0,addr<span class="o">=</span>0x4
</code></pre></div></div> <ol> <li>查看qemu进程的pid</li> </ol> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ps <span class="nt">-aux</span> | <span class="nb">grep </span>qemu
</code></pre></div></div> <ol> <li>GDB调试QEMU</li> </ol> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>gdb qemu-system-x86_64 <span class="o">[</span>pid]
</code></pre></div></div> <ol> <li>GDB中下断点</li> </ol> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>b virtio_balloon_handle_output
</code></pre></div></div> <h3 id="气球模型吸气放气流程">气球模型吸气、放气流程</h3> <h4 id="充气阶段"><strong>充气阶段</strong></h4> <ol> <li><strong>【宿主机：QEMU】</strong>用户通过QEMU monitor发起气球充气请求</li> <li><strong>【宿主机：QEMU】</strong>对请求进行处理，通过系统调用进入到KVM，要求KVM向虚拟机注入中断</li> <li><strong>【宿主机：KVM】</strong>向虚拟机注入中断</li> <li><strong>【虚拟机】</strong>收到中断，执行中断处理函数，调用气球驱动</li> <li><strong>【虚拟机】</strong>在气球驱动中申请内存，将申请到的内存的<strong>虚拟机物理地址</strong>和长度用链表进行维护，并且利用virtio协议填入到内存缓冲区中，注册回调函数</li> <li><strong>【虚拟机】</strong>写MMIO内存陷入到KVM中</li> <li><strong>【宿主机：KVM】</strong>KVM获取陷入原因，将控制权返回到QEMU中</li> <li><strong>【宿主机：QEMU】</strong>QEMU根据virtio协议获取虚拟机分配的内存的虚拟机物理地址，并将其转化为宿主机虚拟地址（QEMU进程地址空间）。<font color="red">然后以NONEED为参数进行madvise系统调用释放内存。</font></li> <li><strong>【宿主机：QEMU】</strong>通过系统调用进入到KVM，要求KVM向虚拟机注入中断</li> <li><strong>【宿主机：KVM】</strong>向虚拟机注入中断</li> <li><strong>【虚拟机】</strong>虚拟机回调函数执行</li> <li><strong>【虚拟机】</strong>虚拟机继续执行</li> </ol> <h4 id="放气阶段"><strong>放气阶段</strong></h4> <ol> <li><strong>【宿主机：QEMU】</strong>用户通过QEMU monitor发起气球充气请求</li> <li><strong>【宿主机：QEMU】</strong>对请求进行处理，通过系统调用进入到KVM，要求KVM向虚拟机注入中断</li> <li><strong>【宿主机：KVM】</strong>向虚拟机注入中断</li> <li><strong>【虚拟机】</strong>收到中断，执行中断处理函数，调用气球驱动</li> <li><strong>【虚拟机】</strong>在气球驱动中将维护的内存取出，并且利用virtio协议填入到内存缓冲区中，注册回调函数</li> <li><strong>【虚拟机】</strong>写MMIO内存陷入到KVM中</li> <li><strong>【宿主机：KVM】</strong>KVM获取陷入原因，将控制权返回到QEMU中</li> <li><strong>【宿主机：QEMU】</strong>QEMU根据virtio协议获取虚拟机分配的内存的虚拟机物理地址，并将其转化为宿主机虚拟地址（QEMU进程地址空间）。<font color="red">然后以WILLNEED为参数进行madvise系统调用。</font></li> <li><strong>【宿主机：QEMU】</strong>通过系统调用进入到KVM，要求KVM向虚拟机注入中断</li> <li><strong>【宿主机：KVM】</strong>向虚拟机注入中断</li> <li><strong>【虚拟机】</strong>虚拟机回调函数执行</li> <li><strong>【虚拟机】</strong>虚拟机继续执行</li> </ol> <h2 id="搭建环境">搭建环境</h2> <ol> <li> <p><strong>下载Linux4.14.173源码</strong></p> </li> <li> <p><strong>编译虚拟机内核</strong></p> </li> </ol> <p><strong>为什么需要重新编译虚拟机内核？</strong></p> <p>下载的虚拟机镜像的balloon和内核完整编译到一起，对于balloon的修改不能以模块的方式的进行；重新编译内核后，不需要使用完整的虚拟机镜像即可实现大部分功能。具体编译内核可以参考wiki：<a href="https://gitee.com/silver-zhou/virtualization_book/wikis/编译内核与调试?sort_id=7980385">编译内核与调试 - Wiki - Gitee.com</a></p> <ol> <li><strong>重新编译QEMU</strong></li> </ol> <p>修改qemu的<code class="language-plaintext highlighter-rouge">configure</code>脚本，将madvise配置修改为禁用：</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if </span>compile_prog <span class="s2">""</span> <span class="s2">""</span> <span class="p">;</span> <span class="k">then
	</span><span class="nv">madvise</span><span class="o">=</span><span class="nb">yes
</span><span class="k">fi
</span><span class="nv">madvise</span><span class="o">=</span>no
</code></pre></div></div> <ol> <li><strong>使用新内核以及新编译好的QEMU启动虚拟机</strong></li> </ol> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>qemu-system-x86_64 <span class="se">\</span>
<span class="nt">-s</span>
<span class="nt">-m</span> 4096
<span class="nt">-smp</span> 4
<span class="nt">-enable-kvm</span>
<span class="nt">-kernel</span> <span class="nv">$KERNEL</span>/bzImage <span class="c">#指定内核镜像</span>
<span class="nt">-append</span> <span class="s2">"root=/dev/sda kgdboc=ttyS0,115200 net.ifnames=0 kvm_intel"</span> <span class="c">#指定启动参数，开启了</span>
<span class="nt">-drive</span> <span class="nv">file</span><span class="o">=</span>stretch.img,format<span class="o">=</span>raw <span class="c">#指定文件系统</span>
<span class="nt">-serial</span> tcp::4321,server,nowait <span class="c">#指定串口</span>
<span class="nt">-net</span> user,host<span class="o">=</span>10.0.2.10,hostfwd<span class="o">=</span>tcp::10021-:22,hostfwd<span class="o">=</span>tcp::10025-:80 <span class="c">#指定端口映射，将22（ssh）映射到宿主机的10021，将80（http）映射到宿主机的10025</span>
<span class="nt">-net</span> nic,model<span class="o">=</span>e1000
<span class="nt">-device</span> virtio-balloon-pci,id<span class="o">=</span>balloon0,bus<span class="o">=</span>pci.0,addr<span class="o">=</span>0x4
</code></pre></div></div> <h2 id="解决思路-2">解决思路</h2> <ol> <li>在虚拟机申请内存后<u>（上文充气阶段步骤5）</u>，向内存写入数据“before inflate”；</li> <li>在QEMU中找到处理气球充气时的处理函数<u>（上文充气阶段步骤8）</u>，输出虚拟机写入的数据，并向内存写入新的数据；</li> <li>在QEMU中取消气球充气时，内存的释放（注：在上文环境搭建步骤3中，已经将QEMU的madvise配置选项修改为了关闭，所以不需要再对应的修改代码）；</li> <li>在虚拟机内核中找到处理气球放气时的处理函数<u>（上文放气阶段步骤11）</u>，输出内存中的信息。</li> </ol> <h2 id="实验-2">实验</h2> <h3 id="虚拟机内写入数据">虚拟机内写入数据</h3> <p>在<code class="language-plaintext highlighter-rouge">balloon_page_alloc</code>函数中：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">balloon_page_alloc</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">balloon_mapping_gfp_mask</span><span class="p">()</span> <span class="o">|</span> <span class="n">__GFP_NOMEMALLOC</span> <span class="o">|</span> <span class="n">__GFP_NORETRY</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">),</span> <span class="s">"before inflate</span><span class="se">\0</span><span class="s">"</span><span class="p">,</span> <span class="mi">15</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">page</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="qemu中拦截页面信息">QEMU中拦截页面信息</h3> <p>在<code class="language-plaintext highlighter-rouge">ram_block_discard_range</code>中，输出虚拟机写入的数据，并且修改内存上的数据。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="n">need_madvise</span><span class="p">){</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"data = %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">host_startaddr</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">host_startaddr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">host_startaddr</span><span class="p">,</span> <span class="s">"after deflate"</span><span class="p">,</span> <span class="mi">13</span><span class="p">);</span>
<span class="k">if</span> <span class="n">defined</span><span class="p">(</span><span class="n">CONFIG_MADVISE</span><span class="p">)</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">madvise</span><span class="p">(</span><span class="n">host_startaddr</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">MADV_DONTNEED</span><span class="p">);</span><span class="c1">//这段代码将不会被执行到</span>
<span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div> <p>有关于madvise系统调用，可以参考wiki：https://gitee.com/silver-zhou/virtualization_book/wikis/madvise%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8?sort_id=7986141</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/book/chapter3/exp3/balloon_inflate_page-480.webp 480w,/assets/img/book/chapter3/exp3/balloon_inflate_page-800.webp 800w,/assets/img/book/chapter3/exp3/balloon_inflate_page-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/book/chapter3/exp3/balloon_inflate_page.png" class="img-fluid rounded z-depth-1" width="70%" height="auto" title="balloon inflate page" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h3 id="修改虚拟机内核输出页面重映射数据">修改虚拟机内核，输出页面重映射数据</h3> <p>在<code class="language-plaintext highlighter-rouge">release_pages_balloon</code>中，将页面上的数据输出：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="o">*</span> <span class="n">page_addr</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="mi">30</span><span class="p">];</span>

<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">pages</span><span class="p">,</span> <span class="n">lru</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">page_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span> <span class="c1">//通过内核函数page_address将page指针转换为虚拟地址</span>

    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4096</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">page_addr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="n">printk</span><span class="p">(</span><span class="s">"data = %c</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
    <span class="n">printk</span><span class="p">(</span><span class="s">"data = %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/book/chapter3/exp3/balloon_deflate_guest-480.webp 480w,/assets/img/book/chapter3/exp3/balloon_deflate_guest-800.webp 800w,/assets/img/book/chapter3/exp3/balloon_deflate_guest-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/book/chapter3/exp3/balloon_deflate_guest.png" class="img-fluid rounded z-depth-1" width="70%" height="auto" title="balloon deflate guest" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure>]]></content><author><name></name></author><category term="配套实验"/><category term="QEMU"/><category term="KVM"/><summary type="html"><![CDATA[这篇文章主要介绍了三个虚拟化实验：EPT页表副本的创建与替换、VMFUNC的创建与使用、气球模型的充气与放气实现，通过这些实验展示了虚拟化技术中内存管理和隔离的关键技术。]]></summary></entry></feed>