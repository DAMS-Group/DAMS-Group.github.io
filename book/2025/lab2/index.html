<!DOCTYPE html> <html lang="cn"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> 第二章实验 | DAMS </title> <meta name="author" content=" "> <meta name="description" content="这篇文章主要介绍了三个KVM虚拟化实验：实现一个简易的KVM虚拟机实例、捕获虚拟机下一条指令地址信息、伪造虚拟机CPUID信息。"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/icon.png?b4018dbfbd52d2e3cc004f2a590839cb"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://dams.net.cn/book/2025/lab2/"> <script src="/assets/js/theme.js?6ddb66544c57e17a63e7abf8cc6c43e3"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav sticky-bottom-footer"> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <img src="/assets/img/icon.png?b4018dbfbd52d2e3cc004f2a590839cb"> DAMS | 分布式与移动系统安全实验室 </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">首页 </a> </li> <li class="nav-item active"> <a class="nav-link" href="/book/">著作 </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">论文 </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">项目 </a> </li> <li class="nav-item "> <a class="nav-link" href="/members/">团队 </a> </li> <li class="nav-item "> <a class="nav-link" href="/news/">新闻 </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link"> <i class="ti ti-search"></i> </span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">第二章实验</h1> <p class="post-meta"> Created in May 01, 2025 </p> <p class="post-tags"> <a href="/book/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a>   ·   <a href="/book/tag/qemu"> <i class="fa-solid fa-hashtag fa-sm"></i> QEMU</a>   <a href="/book/tag/kvm"> <i class="fa-solid fa-hashtag fa-sm"></i> KVM</a>   ·   <a href="/book/category/%E9%85%8D%E5%A5%97%E5%AE%9E%E9%AA%8C"> <i class="fa-solid fa-tag fa-sm"></i> 配套实验</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h1 id="实验一简易kvm虚拟机实例">实验一：简易KVM虚拟机实例</h1> <h2 id="背景知识">背景知识</h2> <p><strong><code class="language-plaintext highlighter-rouge">/dev/kvm</code> 设备</strong></p> <p><code class="language-plaintext highlighter-rouge">/dev/kvm</code> 是一个字符设备，KVM 通过该设备导出了一系列 ioctl 系统调用接口，QEMU 等用户层程序通过这些接口来控制虚拟机。KVM 的 ioctl 接口可以分为三类：</p> <ol> <li>系统全局的 ioctl，这类 ioctl 的作用对象是 KVM 模块，对应内核处理函数入口为 <code class="language-plaintext highlighter-rouge">kvm_dev_ioctl</code>，功能包括获取 KVM 版本，创建 VM 等。</li> <li>虚拟机相关的 ioctl，这类 ioctl 的作用对象是 VM，对应内核处理函数入口为 <code class="language-plaintext highlighter-rouge">kvm_vm_ioctl</code> ，功能包括设置 VM 内存，创建 VCPU 等。</li> <li>虚拟机 VCPU 相关的 ioctl，这类 ioctl 的作用对象是 VCPU，对应内核处理函数入口为 <code class="language-plaintext highlighter-rouge">kvm_vcpu_ioctl</code> ，功能包括设置寄存器，VCPU运行等。</li> </ol> <h2 id="解决思路">解决思路</h2> <p>创建一个简易 KVM 虚拟机实例分为两大部分：</p> <ol> <li>实现一个简易的用户层 QEMU。</li> <li>实现一个简易的 guest 内核。</li> </ol> <h3 id="实现简易的用户层-qemu">实现简易的用户层 QEMU</h3> <p>本书的1.4.1章节中介绍了 KVM 虚拟机与 QEMU 的关系： KVM 的生命周期由 QEMU 管理和维护，一个 KVM 虚拟机可以理解为一个 QEMU 进程，虚拟机的一个 VCPU 对应 QEMU 进程中的一个线程。</p> <p>KVM 导出了一系列 IOCTL 接口供用户层创建、配置、启动虚拟机，典型的用户层软件是 QEMU ，但是从本质上来说，QEMU 和 KVM 可以不必相互依赖，本实验展示简易的用户层程序（后称为简易 QEMU）。</p> <p>该简易 QEMU 主要实现如下几个功能：</p> <ul> <li>创建虚拟机对象</li> <li>为虚拟机分配物理内存、加载 guest 二进制</li> <li>创建虚拟机 VCPU 对象</li> <li>设置 VCPU 的相关寄存器、将 VCPU 调度到物理 CPU 上运行</li> <li>处理 VM Exit 事件</li> </ul> <p><strong>创建虚拟机对象</strong></p> <p>首先打开 <code class="language-plaintext highlighter-rouge">/dev/kvm</code> 设备获取 KVM 模块的文件描述符 <code class="language-plaintext highlighter-rouge">dev_fd</code> ，通过 ioctl(KVM_GET_API_VERSION) 获取 KVM 的版本号，从而使用户层知道相关接口在内核是否有支持。</p> <p>再通过 ioctl(KVM_CREATE_VM) 创建一个虚拟机对象，该 ioctl 返回一个代表虚拟机的文件描述符 <code class="language-plaintext highlighter-rouge">vm_fd</code> ，之后可以通过 <code class="language-plaintext highlighter-rouge">vm_fd</code> 控制虚拟机的内存、VCPU 等。</p> <p><strong>为虚拟机分配物理内存、加载 guest 二进制</strong></p> <p>虚拟机的物理内存对应 QEMU 的进程地址空间，使用 <code class="language-plaintext highlighter-rouge">mmap</code> 分配一定大小的内存作为虚拟机物理内存，然后调用 ioctl(KVM_SET_USER_MEMORY_REGION) 为虚拟机指定一个内存条。接着将简易的 guest 二进制加载到该内存区域。</p> <p><strong>创建虚拟机 VCPU 对象</strong></p> <p>调用 ioctl(KVM_CREATE_VCPU) 创建虚拟机 VCPU 对象，该 ioctl 返回一个代表 VCPU 的文件描述符 <code class="language-plaintext highlighter-rouge">vcpu_fd</code> ，之后通过 <code class="language-plaintext highlighter-rouge">vcpu_fd</code> 控制虚拟机的运行等。</p> <p>虚拟机运行过程中用户层（简易QEMU）和内核层（KVM模块）之间的数据共享是通过 VCPU 维护的 <code class="language-plaintext highlighter-rouge">kvm_run</code> 数据结构来实现的。首先通过调用 ioctl(KVM_GET_VCPU_MMAP_SIZE) 得到该结构的大小，接着调用 <code class="language-plaintext highlighter-rouge">mmap</code> 为 <code class="language-plaintext highlighter-rouge">kvm_run</code> 分配空间。</p> <p><strong>设置 VCPU 的相关寄存器、将 VCPU 调度到物理 CPU 上运行</strong></p> <p>为了让虚拟机 VCPU 运行起来，需要设置 VCPU 的相关寄存器，其中段寄存器和控制寄存器等特殊寄存器存放在 <code class="language-plaintext highlighter-rouge">kvm_sregs</code> 中，通过 ioctl(KVM_GET_SREGS)、ioctl(KVM_SET_SREGS) 读取和修改，通用寄存器存放在 <code class="language-plaintext highlighter-rouge">kvm_regs</code> 中，通过 ioctl(KVM_SET_REGS) 修改。</p> <p>准备工作完毕，可以让虚拟机运行起来了，通常在一个死循环中对 <code class="language-plaintext highlighter-rouge">vcpu_fd</code> 调用 ioctl(KVM_RUN)。KVM 内核模块在处理这个 ioctl 时会把 VCPU 调度到物理 CPU 上运行，遇到 KVM 无法处理的退出事件则会返回到此处，处理完之后再次进入循环调用 ioctl(KVM_RUN) 进入虚拟机。</p> <p><strong>处理 VM Exit 事件</strong></p> <p>内核 KVM 无法处理时，会将信息保存到 <code class="language-plaintext highlighter-rouge">kvm_run</code> 并 return 0，用户层则可以通过读取该共享内存得知虚拟机退出原因，进行相应的处理。本例包括 guest 向 I/O 端口写数据产生的 <code class="language-plaintext highlighter-rouge">KVM_EXIT_IO</code> 退出的处理、执行 HALT 指令等。</p> <h3 id="实现简易的-guest-内核">实现简易的 guest 内核</h3> <p>简易内核主要实现一些能触发 VM Exit 的操作，包括向 I/O 端口写数据、执行 HALT 指令。汇编文件如下</p> <pre><code class="language-assembly">// guest_test.S

.globl _start
    .code16
_start:
    xorw %ax, %ax

    out %ax, $0x10
    inc %ax
    out %ax, $0x10
    inc %ax
    out %ax, $0x10

    hlt
</code></pre> <p>编译</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>as <span class="nt">-32</span> guest_test.S <span class="nt">-o</span> guest_test.o
<span class="nv">$ </span>ld <span class="nt">-m</span> elf_i386 <span class="nt">--oformat</span> binary <span class="nt">-e</span> _start <span class="nt">-Ttext</span> 0x0 <span class="nt">-o</span> guest_test.bin guest_test.o
</code></pre></div></div> <p>相关链接参数说明：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-m EMULATION                Set emulation
-e ADDRESS, --entry ADDRESS Set start address
--oformat TARGET            Specify target of output file
-Ttext ADDRESS              Set address of .text section
-o FILE, --output FILE      Set output file name
</code></pre></div></div> <h2 id="编译执行">编译执行</h2> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>make
as <span class="nt">-32</span> guest_test.S <span class="nt">-o</span> guest_test.o
ld <span class="nt">-m</span> elf_i386 <span class="nt">--oformat</span> binary <span class="nt">-e</span> _start <span class="nt">-Ttext</span> 0x0 <span class="nt">-o</span> guest_test.bin guest_test.o

<span class="nv">$ </span><span class="nb">ls
</span>guest_test.bin  guest_test.S  qemu_sample    qemu_sample.o
guest_test.o    Makefile      qemu_sample.c

<span class="nv">$ </span>./qemu_sample
open /dev/kvm...
get vm fd...
load guest_test.bin...
get vcpu fd...
<span class="nb">set </span>vcpu regs...
vcpu run...
KVM_EXIT_IO
guest put io data: 0
vcpu run...
KVM_EXIT_IO
guest put io data: 1
vcpu run...
KVM_EXIT_IO
guest put io data: 2
vcpu run...
KVM_EXIT_HLT

</code></pre></div></div> <h1 id="实验二捕获虚拟机下一条指令地址信息">实验二：捕获虚拟机下一条指令地址信息</h1> <h2 id="背景知识-1">背景知识</h2> <p>下一条指令信息，存放在虚拟机的 CS：RIP 中，需要使用VMX系列指令读取VMCS相关字段</p> <h2 id="解决思路-1">解决思路</h2> <p>内核中封装了一些 vmcs 读取相关的函数：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp"># linux-5.15/arch/x86/kvm/vmx/vmx_ops.h
</span>
<span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">__vmcs_readl</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">field</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">value</span><span class="p">;</span>

	<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">"1: vmread %2, %1</span><span class="se">\n\t</span><span class="s">"</span>
		     <span class="s">".byte 0x3e</span><span class="se">\n\t</span><span class="s">"</span> <span class="cm">/* branch taken hint */</span>
		     <span class="s">"ja 3f</span><span class="se">\n\t</span><span class="s">"</span>

		     <span class="cm">/*
		      * VMREAD failed.  Push '0' for @fault, push the failing
		      * @field, and bounce through the trampoline to preserve
		      * volatile registers.
		      */</span>
		     <span class="s">"push $0</span><span class="se">\n\t</span><span class="s">"</span>
		     <span class="s">"push %2</span><span class="se">\n\t</span><span class="s">"</span>
		     <span class="s">"2:call vmread_error_trampoline</span><span class="se">\n\t</span><span class="s">"</span>

		     <span class="cm">/*
		      * Unwind the stack.  Note, the trampoline zeros out the
		      * memory for @fault so that the result is '0' on error.
		      */</span>
		     <span class="s">"pop %2</span><span class="se">\n\t</span><span class="s">"</span>
		     <span class="s">"pop %1</span><span class="se">\n\t</span><span class="s">"</span>
		     <span class="s">"3:</span><span class="se">\n\t</span><span class="s">"</span>

		     <span class="cm">/* VMREAD faulted.  As above, except push '1' for @fault. */</span>
		     <span class="s">".pushsection .fixup, </span><span class="se">\"</span><span class="s">ax</span><span class="se">\"\n\t</span><span class="s">"</span>
		     <span class="s">"4: push $1</span><span class="se">\n\t</span><span class="s">"</span>
		     <span class="s">"push %2</span><span class="se">\n\t</span><span class="s">"</span>
		     <span class="s">"jmp 2b</span><span class="se">\n\t</span><span class="s">"</span>
		     <span class="s">".popsection</span><span class="se">\n\t</span><span class="s">"</span>
		     <span class="n">_ASM_EXTABLE</span><span class="p">(</span><span class="mi">1</span><span class="n">b</span><span class="p">,</span> <span class="mi">4</span><span class="n">b</span><span class="p">)</span>
		     <span class="o">:</span> <span class="n">ASM_CALL_CONSTRAINT</span><span class="p">,</span> <span class="s">"=r"</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">:</span> <span class="s">"r"</span><span class="p">(</span><span class="n">field</span><span class="p">)</span> <span class="o">:</span> <span class="s">"cc"</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__always_inline</span> <span class="n">u16</span> <span class="nf">vmcs_read16</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">field</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vmcs_check16</span><span class="p">(</span><span class="n">field</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">static_branch_unlikely</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enable_evmcs</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">evmcs_read16</span><span class="p">(</span><span class="n">field</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">__vmcs_readl</span><span class="p">(</span><span class="n">field</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">vmcs_readl</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">field</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vmcs_checkl</span><span class="p">(</span><span class="n">field</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">static_branch_unlikely</span><span class="p">(</span><span class="o">&amp;</span><span class="n">enable_evmcs</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">evmcs_read64</span><span class="p">(</span><span class="n">field</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">__vmcs_readl</span><span class="p">(</span><span class="n">field</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>在 VM Exit 后，guest 相关信息会保存到 VMCS 字段，KVM 在 <code class="language-plaintext highlighter-rouge">vmx_handle_exit</code> 函数根据退出原因进行处理，处理完成后，再次返回虚拟机之前（VMENTRY/VMRESUME），下一条指令的地址信息保存VMCS中Guest相关字段中，在此可以查看虚拟机 CS：RIP 信息。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp"># linux-5.15/arch/x86/kvm/vmx/vmx.c
</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vmx_handle_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">fastpath_t</span> <span class="n">exit_fastpath</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">__vmx_handle_exit</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">exit_fastpath</span><span class="p">);</span>

    <span class="c1">// 获取当前VMCS的guest_rip和guest_cs字段</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">"GUEST CS:RIP=%04x:0x%016lx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
	       <span class="n">vmcs_read16</span><span class="p">(</span><span class="n">GUEST_CS_SELECTOR</span><span class="p">),</span> <span class="n">vmcs_readl</span><span class="p">(</span><span class="n">GUEST_RIP</span><span class="p">));</span>
	<span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="输出结果">输出结果</h2> <p>在linux目录下应用patch，运行编译脚本文件，dmesg查看输出。</p> <p>通过 <code class="language-plaintext highlighter-rouge">dmesg</code> 查看内核输出信息如下</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>dmesg
<span class="o">[</span>1476092.242576] GUEST CS:RIP<span class="o">=</span>0010:0xffffffffb768dc17
<span class="o">[</span>1476092.242579] GUEST CS:RIP<span class="o">=</span>0010:0xffffffffb768dc17
<span class="o">[</span>1476092.242581] GUEST CS:RIP<span class="o">=</span>0033:0x00005568d139af28
<span class="o">[</span>1476092.242582] GUEST CS:RIP<span class="o">=</span>0033:0x00005568d139af28
<span class="o">[</span>1476092.242584] GUEST CS:RIP<span class="o">=</span>0010:0xffffffffb768dc17
<span class="o">[</span>1476092.242587] GUEST CS:RIP<span class="o">=</span>0033:0x00005568d139af28
<span class="o">[</span>1476092.242597] GUEST CS:RIP<span class="o">=</span>0010:0xffffffffb768dc17
<span class="o">[</span>1476092.242602] GUEST CS:RIP<span class="o">=</span>0010:0xffffffffb768dc17
<span class="o">[</span>1476092.242606] GUEST CS:RIP<span class="o">=</span>0010:0xffffffffb768dc17
<span class="o">[</span>1476092.242611] GUEST CS:RIP<span class="o">=</span>0010:0xffffffffb768dc17
<span class="o">[</span>1476092.242616] GUEST CS:RIP<span class="o">=</span>0033:0x00005568d13ee0b5
<span class="o">[</span>1476092.242641] GUEST CS:RIP<span class="o">=</span>0010:0xffffffffb768dc17
<span class="o">[</span>1476092.242644] GUEST CS:RIP<span class="o">=</span>0033:0x00005568d13fa710
<span class="o">[</span>1476092.242647] GUEST CS:RIP<span class="o">=</span>0010:0xffffffffb768dc17
<span class="o">[</span>1476092.242651] GUEST CS:RIP<span class="o">=</span>0010:0xffffffffb768dc17
<span class="o">[</span>1476092.242680] GUEST CS:RIP<span class="o">=</span>0010:0xffffffffb768dc17
<span class="o">[</span>1476092.242684] GUEST CS:RIP<span class="o">=</span>0010:0xffffffffb768dc17
</code></pre></div></div> <h1 id="实验三伪造虚拟机-cpuid-信息">实验三：伪造虚拟机 CPUID 信息</h1> <h2 id="背景知识-2">背景知识</h2> <p>CPUID 指令</p> <ul> <li>CPUID 指令主要用来获取处理器的 identification 和 feature 信息，输入参数通过 EAX、ECX 寄存器传入，输出的值返回到 EAX、EBX、ECX、EDX 寄存器。</li> </ul> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/book/chapter2/exp3/CPUID-desc-480.webp 480w,/assets/img/book/chapter2/exp3/CPUID-desc-800.webp 800w,/assets/img/book/chapter2/exp3/CPUID-desc-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/book/chapter2/exp3/CPUID-desc.png" class="img-fluid rounded z-depth-1" width="70%" height="auto" title="CPUID-desc" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <ul> <li>指令操作码及相应字段含义详细参考 <a href="https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-2a-manual.pdf" rel="external nofollow noopener" target="_blank">Intel 手册 vol 2a</a> </li> </ul> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/book/chapter2/exp3/ia-32-480.webp 480w,/assets/img/book/chapter2/exp3/ia-32-800.webp 800w,/assets/img/book/chapter2/exp3/ia-32-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/book/chapter2/exp3/ia-32.png" class="img-fluid rounded z-depth-1" width="70%" height="auto" title="ia-32" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <h2 id="解决思路-2">解决思路</h2> <p>在 guest 中查看 CPU 相关信息：</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/book/chapter2/exp3/CPUinfo-guest-480.webp 480w,/assets/img/book/chapter2/exp3/CPUinfo-guest-800.webp 800w,/assets/img/book/chapter2/exp3/CPUinfo-guest-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/book/chapter2/exp3/CPUinfo-guest.png" class="img-fluid rounded z-depth-1" width="70%" height="auto" title="CPUinfo-guest" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>CPUID 指令的模拟在 <code class="language-plaintext highlighter-rouge">kvm_emulate_cpuid</code> 函数，首先从eax、ecx寄存器读取指令操作码等，然后调用 <code class="language-plaintext highlighter-rouge">kvm_cpuid</code> 遍历 <code class="language-plaintext highlighter-rouge">vcpu-&gt;arch.cpuid_entries</code> 表找出与本操作码对应的 entry，然后将 entry 中四个寄存器eax、ebx、ecx、edx的值读出。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp"># linux-5.15/arch/x86/kvm/cpuid.c
</span>
<span class="n">bool</span> <span class="nf">kvm_cpuid</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">eax</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">ebx</span><span class="p">,</span>
	       <span class="n">u32</span> <span class="o">*</span><span class="n">ecx</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">edx</span><span class="p">,</span> <span class="n">bool</span> <span class="n">exact_only</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">orig_function</span> <span class="o">=</span> <span class="o">*</span><span class="n">eax</span><span class="p">,</span> <span class="n">function</span> <span class="o">=</span> <span class="o">*</span><span class="n">eax</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="o">*</span><span class="n">ecx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_cpuid_entry2</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">exact</span><span class="p">,</span> <span class="n">used_max_basic</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">kvm_find_cpuid_entry</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
	<span class="n">exact</span> <span class="o">=</span> <span class="o">!!</span><span class="n">entry</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">exact_only</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">get_out_of_range_cpuid_entry</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">function</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
		<span class="n">used_max_basic</span> <span class="o">=</span> <span class="o">!!</span><span class="n">entry</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">eax</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">eax</span><span class="p">;</span>
		<span class="o">*</span><span class="n">ebx</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">ebx</span><span class="p">;</span>
		<span class="o">*</span><span class="n">ecx</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">ecx</span><span class="p">;</span>
		<span class="o">*</span><span class="n">edx</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">edx</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">function</span> <span class="o">==</span> <span class="mi">7</span> <span class="o">&amp;&amp;</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u64</span> <span class="n">data</span><span class="p">;</span>
		        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__kvm_get_msr</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">MSR_IA32_TSX_CTRL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="nb">true</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">TSX_CTRL_CPUID_CLEAR</span><span class="p">))</span>
				<span class="o">*</span><span class="n">ebx</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">F</span><span class="p">(</span><span class="n">RTM</span><span class="p">)</span> <span class="o">|</span> <span class="n">F</span><span class="p">(</span><span class="n">HLE</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">eax</span> <span class="o">=</span> <span class="o">*</span><span class="n">ebx</span> <span class="o">=</span> <span class="o">*</span><span class="n">ecx</span> <span class="o">=</span> <span class="o">*</span><span class="n">edx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/*
		 * When leaf 0BH or 1FH is defined, CL is pass-through
		 * and EDX is always the x2APIC ID, even for undefined
		 * subleaves. Index 1 will exist iff the leaf is
		 * implemented, so we pass through CL iff leaf 1
		 * exists. EDX can be copied from any existing index.
		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">function</span> <span class="o">==</span> <span class="mh">0xb</span> <span class="o">||</span> <span class="n">function</span> <span class="o">==</span> <span class="mh">0x1f</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">entry</span> <span class="o">=</span> <span class="n">kvm_find_cpuid_entry</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">ecx</span> <span class="o">=</span> <span class="n">index</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
				<span class="o">*</span><span class="n">edx</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">edx</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">trace_kvm_cpuid</span><span class="p">(</span><span class="n">orig_function</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="o">*</span><span class="n">eax</span><span class="p">,</span> <span class="o">*</span><span class="n">ebx</span><span class="p">,</span> <span class="o">*</span><span class="n">ecx</span><span class="p">,</span> <span class="o">*</span><span class="n">edx</span><span class="p">,</span> <span class="n">exact</span><span class="p">,</span>
			<span class="n">used_max_basic</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">exact</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">kvm_emulate_cpuid</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">eax</span><span class="p">,</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">edx</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cpuid_fault_enabled</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">kvm_require_cpl</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">eax</span> <span class="o">=</span> <span class="n">kvm_rax_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">ecx</span> <span class="o">=</span> <span class="n">kvm_rcx_read</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
	<span class="n">kvm_cpuid</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eax</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ebx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ecx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">edx</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="n">kvm_rax_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">eax</span><span class="p">);</span>
	<span class="n">kvm_rbx_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">ebx</span><span class="p">);</span>
	<span class="n">kvm_rcx_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">ecx</span><span class="p">);</span>
	<span class="n">kvm_rdx_write</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">edx</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">kvm_skip_emulated_instruction</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>其中 <strong><code class="language-plaintext highlighter-rouge">vcpu-&gt;arch.cpuid_entries</code> 表的设置</strong>：该entries是一个结构数组，由qemu和kvm共同维护，qemu在 <code class="language-plaintext highlighter-rouge">kvm_arch_init_vcpu</code> 函数中设置完 entries 的值之后，调用 <code class="language-plaintext highlighter-rouge">kvm_vcpu_ioctl(cs, KVM_SET_CPUID2, &amp;cpuid_data)</code> 进入kvm，kvm中 <code class="language-plaintext highlighter-rouge">kvm_vcpu_ioctl_set_cpuid2</code> 函数再进一步设置。</p> <p>本实验<strong>以“model name”项</strong>为例进行测试，根据 Intel 手册该项对应的 CPUID 指令的操作码为 0x80000002～0x80000004，在 <code class="language-plaintext highlighter-rouge">kvm_cpuid</code> 中进行操作码匹配，对相应的寄存器进行修改。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">bool</span> <span class="nf">kvm_cpuid</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">eax</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">ebx</span><span class="p">,</span>
	       <span class="n">u32</span> <span class="o">*</span><span class="n">ecx</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">edx</span><span class="p">,</span> <span class="n">bool</span> <span class="n">exact_only</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">orig_function</span> <span class="o">=</span> <span class="o">*</span><span class="n">eax</span><span class="p">,</span> <span class="n">function</span> <span class="o">=</span> <span class="o">*</span><span class="n">eax</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="o">*</span><span class="n">ecx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_cpuid_entry2</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">exact</span><span class="p">,</span> <span class="n">used_max_basic</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/*set model_id fake value*/</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">model_id</span> <span class="o">=</span> <span class="s">"modify cpuid-model for test"</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cpuid_model</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">model_id</span><span class="p">);</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">cpuid_model</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">48</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">48</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">c</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">model_id</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="n">cpuid_model</span><span class="p">[</span><span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">]</span> <span class="o">|=</span> <span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">8</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">));</span>
    <span class="p">}</span>
	<span class="cm">/*set cpuid_model fake value*/</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">kvm_find_cpuid_entry</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
	<span class="n">exact</span> <span class="o">=</span> <span class="o">!!</span><span class="n">entry</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">exact_only</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">get_out_of_range_cpuid_entry</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">function</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
		<span class="n">used_max_basic</span> <span class="o">=</span> <span class="o">!!</span><span class="n">entry</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">eax</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">eax</span><span class="p">;</span>
		<span class="o">*</span><span class="n">ebx</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">ebx</span><span class="p">;</span>
		<span class="o">*</span><span class="n">ecx</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">ecx</span><span class="p">;</span>
		<span class="o">*</span><span class="n">edx</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">edx</span><span class="p">;</span>

		<span class="cm">/*****case model-id modify test*/</span>
		<span class="k">if</span><span class="p">(</span><span class="n">function</span> <span class="o">==</span> <span class="mh">0x80000002</span> <span class="o">||</span> <span class="n">function</span> <span class="o">==</span> <span class="mh">0x80000003</span> <span class="o">||</span> <span class="n">function</span> <span class="o">==</span> <span class="mh">0x80000004</span><span class="p">){</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">"index:0x%x, cpuid_model=0x%x"</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">cpuid_model</span><span class="p">[(</span><span class="n">function</span> <span class="o">-</span> <span class="mh">0x80000002</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">0</span><span class="p">]);</span>
			<span class="o">*</span><span class="n">eax</span> <span class="o">=</span> <span class="n">cpuid_model</span><span class="p">[(</span><span class="n">function</span> <span class="o">-</span> <span class="mh">0x80000002</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">0</span><span class="p">];</span>
			<span class="o">*</span><span class="n">ebx</span> <span class="o">=</span> <span class="n">cpuid_model</span><span class="p">[(</span><span class="n">function</span> <span class="o">-</span> <span class="mh">0x80000002</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
			<span class="o">*</span><span class="n">ecx</span> <span class="o">=</span> <span class="n">cpuid_model</span><span class="p">[(</span><span class="n">function</span> <span class="o">-</span> <span class="mh">0x80000002</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span>
			<span class="o">*</span><span class="n">edx</span> <span class="o">=</span> <span class="n">cpuid_model</span><span class="p">[(</span><span class="n">function</span> <span class="o">-</span> <span class="mh">0x80000002</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">3</span><span class="p">];</span>
		<span class="p">}</span>
		<span class="cm">/*****case model-id modify test*/</span>
		<span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div> <p>编译运行结果如下:</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/book/chapter2/exp3/modify-cpuid-model-test-480.webp 480w,/assets/img/book/chapter2/exp3/modify-cpuid-model-test-800.webp 800w,/assets/img/book/chapter2/exp3/modify-cpuid-model-test-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/book/chapter2/exp3/modify-cpuid-model-test.png" class="img-fluid rounded z-depth-1" width="70%" height="auto" title="modify-cpuid-model-test" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </article> <div id="giscus_thread" style="max-width: 1600px; margin: 0 auto;"> <script>
      let giscusTheme = determineComputedTheme();
      let giscusAttributes = {
        src: 'https://giscus.app/client.js',
        'data-repo': 'DAMS-Group/DAMS-Group.github.io',
        'data-repo-id': 'R_kgDOOirvnQ',
        'data-category': 'Announcements',
        'data-category-id': 'DIC_kwDOOirvnc4Cpr6o',
        'data-mapping': 'title',
        'data-strict': '1',
        'data-reactions-enabled': '1',
        'data-emit-metadata': '0',
        'data-input-position': 'top',
        'data-theme': giscusTheme,
        'data-lang': 'zh-CN',
        'data-loading': 'lazy',
        crossorigin: 'anonymous',
        async: '',
      };

      let giscusScript = document.createElement('script');
      Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value));
      document.getElementById('giscus_thread').appendChild(giscusScript);
    </script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025. 分布式与移动系统安全实验室. All rights reserved. Last updated: May 16, 2025. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>