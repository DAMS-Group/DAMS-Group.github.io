<!DOCTYPE html> <html lang="cn"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> 第三章实验 | DAMS </title> <meta name="author" content=" "> <meta name="description" content="这篇文章主要介绍了三个虚拟化实验：EPT页表副本的创建与替换、VMFUNC的创建与使用、气球模型的充气与放气实现，通过这些实验展示了虚拟化技术中内存管理和隔离的关键技术。"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/icon.png?b4018dbfbd52d2e3cc004f2a590839cb"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://dams.net.cn/book/2025/lab3/"> <script src="/assets/js/theme.js?6ddb66544c57e17a63e7abf8cc6c43e3"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav sticky-bottom-footer"> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> DAMS | 分布式与移动系统安全实验室 </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">首页 </a> </li> <li class="nav-item active"> <a class="nav-link" href="/book/">著作 </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">论文 </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">项目 </a> </li> <li class="nav-item "> <a class="nav-link" href="/members/">团队 </a> </li> <li class="nav-item "> <a class="nav-link" href="/news/">新闻 </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link"> <i class="ti ti-search"></i> </span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">第三章实验</h1> <p class="post-meta"> Created in April 01, 2025 </p> <p class="post-tags"> <a href="/book/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a>   ·   <a href="/book/tag/qemu"> <i class="fa-solid fa-hashtag fa-sm"></i> QEMU</a>   <a href="/book/tag/kvm"> <i class="fa-solid fa-hashtag fa-sm"></i> KVM</a>   ·   <a href="/book/category/%E9%85%8D%E5%A5%97%E5%AE%9E%E9%AA%8C"> <i class="fa-solid fa-tag fa-sm"></i> 配套实验</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h1 id="实验一ept页表副本的创建与替换">实验一：EPT页表副本的创建与替换</h1> <p><strong>创建EPT页表副本，在虚拟机从实模式跳转到保护模式时替换原有的EPT页表</strong></p> <h2 id="解决思路">解决思路</h2> <p>如3.3.3中提到的，<code class="language-plaintext highlighter-rouge">vmx_load_mmu_pgd</code>函数中完成了EPT页表的加载：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="n">enable_ept</span><span class="p">){</span>
    <span class="n">eptp</span> <span class="o">=</span> <span class="n">construct_eptp</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">root_hpa</span><span class="p">,</span> <span class="n">root_level</span><span class="p">);</span>
    <span class="n">vmcs_write64</span><span class="p">(</span><span class="n">EPT_POINTER</span><span class="p">,</span> <span class="n">eptp</span><span class="p">);</span>
    <span class="p">......</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">vmx_load_mmu_pgd</code>调用了<code class="language-plaintext highlighter-rouge">construct_eptp</code>，将其返回值（<code class="language-plaintext highlighter-rouge">eptp</code>）写入到 <strong>VMCS</strong> 的 <strong>EPT_POINTER</strong> 字段。</p> <p><code class="language-plaintext highlighter-rouge">construct_eptp</code>函数中仅仅是根据Intel手册中对于<strong>VMCS</strong>的<strong>EPT_POINTER</strong>字段的规定进行数据的“组装”，关键点在其参数<code class="language-plaintext highlighter-rouge">root_hpa</code>。<code class="language-plaintext highlighter-rouge">root_hpa</code>是<code class="language-plaintext highlighter-rouge">kvm_mmu_load_pgd</code>调用<code class="language-plaintext highlighter-rouge">vmx_load_mmu_pgd</code>时提供的参数：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">kvm_mmu_load_pgd</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">u64</span> <span class="n">root_hpa</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="o">-&gt;</span><span class="n">root_hpa</span><span class="p">;</span>
    <span class="p">...</span>
    <span class="n">static_call</span><span class="p">(</span><span class="n">kvm_x86_load_mmu_pgd</span><span class="p">)(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">root_hpa</span><span class="p">,</span>
                                     <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="o">-&gt;</span><span class="n">shadow_root_level</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>继续跟踪<code class="language-plaintext highlighter-rouge">vcpu-&gt;arch.mmu-&gt;root_hpa</code>的来源，<code class="language-plaintext highlighter-rouge">kvm_mmu_load</code>函数调用了<code class="language-plaintext highlighter-rouge">kvm_mmu_load_pgd</code>，<code class="language-plaintext highlighter-rouge">kvm_mmu_load</code>函数如下：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">kvm_mmu_load</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
    <span class="p">...</span>
    <span class="k">if</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="o">-&gt;</span><span class="n">direct_map</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">mmu_alloc_direct_roots</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>

    <span class="p">...</span>
    <span class="n">kvm_mmu_load_pgd</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>采用了EPT的地址转换方案时，<code class="language-plaintext highlighter-rouge">vcpu-&gt;arch.mmu.direct_map</code>的值为<code class="language-plaintext highlighter-rouge">True</code>（可以参考本书的3.3.2节的<code class="language-plaintext highlighter-rouge">init_kvm_tdp_mmu</code>函数讲解），所以会进入<code class="language-plaintext highlighter-rouge">mmu_alloc_direct_roots(vcpu)</code>分支：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">mmu_alloc_direct_roots</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hpa_t</span> <span class="n">root</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">is_tdp_mmu_get_vcpu_root_hpa</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">)){</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">kvm_tdp_mmu_get_vcpu_root_hpa</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
        <span class="n">mmu</span><span class="o">-&gt;</span><span class="n">root_hpa</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div> <p>其调用了<code class="language-plaintext highlighter-rouge">kvm_tdp_mmu_get_vcpu_root_hpa</code>，该函数实现如下：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">hpa_t</span> <span class="nf">kvm_tdp_mmu_get_vcpu_root_hpa</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">kvm_mmu_page_role</span> <span class="n">role</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="o">*</span><span class="n">root_copy</span><span class="p">;</span>

	<span class="n">lockdep_assert_held_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>

	<span class="n">role</span> <span class="o">=</span> <span class="n">page_role_for_level</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="o">-&gt;</span><span class="n">shadow_root_level</span><span class="p">);</span>

	<span class="cm">/* Check for an existing root before allocating a new one. */</span>
	<span class="n">for_each_tdp_mmu_root</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">kvm_mmu_role_as_id</span><span class="p">(</span><span class="n">role</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">role</span><span class="p">.</span><span class="n">word</span> <span class="o">==</span> <span class="n">role</span><span class="p">.</span><span class="n">word</span> <span class="o">&amp;&amp;</span>
		    <span class="n">kvm_tdp_mmu_get_root</span><span class="p">(</span><span class="n">kvm</span><span class="p">,</span> <span class="n">root</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">root</span> <span class="o">=</span> <span class="n">alloc_tdp_mmu_page</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="o">-&gt;</span><span class="n">shadow_root_level</span><span class="p">);</span>
	<span class="n">refcount_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">tdp_mmu_root_count</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">tdp_mmu_pages_lock</span><span class="p">);</span>
	<span class="n">list_add_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">tdp_mmu_roots</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">tdp_mmu_pages_lock</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">__pa</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">spt</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>在没有找到已经存在的root的情况下会创建新的root，调用<code class="language-plaintext highlighter-rouge">alloc_tdp_mmu_page</code>，其具体实现在本书的3.3.4节进行过详细介绍。</p> <p>所以我们可以在<code class="language-plaintext highlighter-rouge">kvm_tdp_mmu_get_vcpu_root_hpa</code>中构造EPT副本的根目录。</p> <h2 id="实验">实验</h2> <ol> <li>在<code class="language-plaintext highlighter-rouge">struct kvm_vcpu</code>中添加一个成员变量<code class="language-plaintext highlighter-rouge">bool rebuild_ept</code>；</li> <li>在<code class="language-plaintext highlighter-rouge">kvm_set_cr0</code>中添加判断开启分页的语句，并将<code class="language-plaintext highlighter-rouge">rebuild_ept</code>设置为<code class="language-plaintext highlighter-rouge">true</code>；</li> <li>在<code class="language-plaintext highlighter-rouge">kvm_tdp_mmu_get_vcpu_root_hpa</code>中添加创建EPTP副本的代码，通过一个if语句控制，创建完成后将<code class="language-plaintext highlighter-rouge">rebuild_ept</code>设置为<code class="language-plaintext highlighter-rouge">false</code>。</li> </ol> <p><strong>实验结果</strong></p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dmesg
</code></pre></div></div> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/book/chapter3/exp1/1679042004764-480.webp 480w,/assets/img/book/chapter3/exp1/1679042004764-800.webp 800w,/assets/img/book/chapter3/exp1/1679042004764-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/book/chapter3/exp1/1679042004764.png" class="img-fluid rounded z-depth-1" width="70%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <h1 id="实验二vmfunc的创建与使用">实验二：VMFUNC的创建与使用</h1> <p><strong>创建多个EPT页表，并使用EPTP机制对虚拟机线程进行页表隔离与切换</strong></p> <h2 id="背景知识">背景知识</h2> <p>开启VMFUNC功能需要：</p> <ol> <li>VM-Function的第0位置1，其余位为0；</li> <li>“activate secondary controls”VM-execution控制位（bit 31）置位1；</li> <li>“enable VM functions”VM-execution控制位（bit 13）置位1；</li> <li>指定EPTP list的地址；</li> <li>向EPTP List中填入适当的EPTP。</li> </ol> <h2 id="解决思路-1">解决思路</h2> <p>为了完成实验目标，主要需要以下步骤：</p> <p><strong>KVM端</strong>：</p> <ol> <li>开启VMFUNC支持；</li> <li>为EPTP List分配内存，在VMCS中写入EPTP List的地址</li> <li>创建EPTP页表副本，在EPTP List中写入地址</li> <li>在EPT violation中进行设置，检测到Non-root模式调用VMFUNC后，置换root_hpa指针</li> <li>在虚拟机退出时释放EPTP List所在页</li> <li>在卸载MMU时释放创建的页表副本。</li> </ol> <p><strong>虚拟机内</strong>：</p> <ol> <li>启动新的线程，在进程创建和退出时都调用VMFUNC</li> </ol> <h2 id="实验-1">实验</h2> <h3 id="开启vmfunc支持">开启VMFUNC支持</h3> <ul> <li>KVM中activate secondary control已经默认开启</li> <li>enable VM functions默认关闭</li> <li>VM-Function控制位未开启</li> </ul> <p>在<code class="language-plaintext highlighter-rouge">./arch/x86/kvm/vmx/vmx.c</code>中，修改<code class="language-plaintext highlighter-rouge">vmx_secondary_exec_control</code>函数：</p> <div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gi">+++ exec_control |= SECONDARY_EXEC_ENABLE_VMFUNC
</span></code></pre></div></div> <p>在<code class="language-plaintext highlighter-rouge">./arch/x86/kvm/vmx/vmx.c</code>中，修改<code class="language-plaintext highlighter-rouge">init_vmcs</code>函数：</p> <pre><code class="language-C">if (cpu_has_vmx_vmfunc()){
	printk("[init_vmcs]: secondary turn on\n");
	vmcs_write64(VM_FUNCTION_CONTROL, 1);//最低位置1
}
</code></pre> <h3 id="为eptp-list分配内存在vmcs中写入eptp-list的地址">为EPTP List分配内存，在VMCS中写入EPTP List的地址</h3> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">vmx_enable_ept_switching</span><span class="p">(</span><span class="k">struct</span> <span class="n">vcpu_vmx</span> <span class="o">*</span><span class="n">vmx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">eptp_list_pg</span><span class="p">;</span>

	<span class="n">eptp_list_pg</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">GFP_KERNEL</span> <span class="o">|</span> <span class="n">__GFP_ZERO</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">eptp_list_pg</span><span class="p">){</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vmx</span><span class="o">-&gt;</span><span class="n">eptp_list_pg</span> <span class="o">=</span> <span class="n">eptp_list_pg</span><span class="p">;</span>

	<span class="n">vmcs_write64</span><span class="p">(</span><span class="n">EPTP_LIST_ADDRESS</span><span class="p">,</span> <span class="n">page_to_phys</span><span class="p">(</span><span class="n">vmx</span><span class="o">-&gt;</span><span class="n">eptp_list_pg</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="在eptp-list中写入地址">在EPTP List中写入地址</h3> <p>在<code class="language-plaintext highlighter-rouge">vmx_load_mmu_pgd</code>中：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">if</span> <span class="p">(</span><span class="n">enable_ept</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">eptp</span> <span class="o">=</span> <span class="n">construct_eptp</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">root_hpa</span><span class="p">,</span> <span class="n">root_level</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">eptp_list_pg</span><span class="p">){</span>
			<span class="n">eptp_list</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="n">phys_to_virt</span><span class="p">(</span><span class="n">page_to_phys</span><span class="p">(</span><span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">eptp_list_pg</span><span class="p">));</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">EPTP_LIST_NUM</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
				<span class="n">eptp_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">eptp</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
</code></pre></div></div> <h3 id="创建页表副本">创建页表副本</h3> <p>在<code class="language-plaintext highlighter-rouge">struct kvm_mmu *mmu</code>中创建一个成员变量：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define KVM_EPTP_NUMBER 1//EPTP的数量按需设置
</span><span class="k">struct</span> <span class="n">kvm_mmu</span><span class="p">{</span>
    <span class="p">...</span>
    <span class="n">hpa_t</span> <span class="n">new_root_hpa</span><span class="p">[</span><span class="n">KVM_EPTP_NUMBERS</span><span class="p">];</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div> <p>然后为新的根分配内存，参考<code class="language-plaintext highlighter-rouge">kvm_tdp_mmu_get_vcpu_root_hpa</code>实现了<code class="language-plaintext highlighter-rouge">new_kvm_tdp_mmu_get_vcpu_root_hpa</code></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">mmu_alloc_direct_roots</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">){</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">is_tdp_mmu_enabled</span><span class="p">(</span><span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">root</span> <span class="o">=</span> <span class="n">kvm_tdp_mmu_get_vcpu_root_hpa</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="n">mmu</span><span class="o">-&gt;</span><span class="n">root_hpa</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">KVM_EPTP_NUMBERS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
			<span class="n">mmu</span><span class="o">-&gt;</span><span class="n">new_root_hpa</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_kvm_tdp_mmu_get_vcpu_root_hpa</span><span class="p">(</span><span class="n">vcpu</span><span class="p">);</span>
		<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">hpa_t</span> <span class="nf">new_kvm_tdp_mmu_get_vcpu_root_hpa</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">){</span>
    <span class="k">union</span> <span class="n">kvm_mmu_page_role</span> <span class="n">role</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">kvm</span> <span class="o">*</span><span class="n">kvm</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">kvm</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">kvm_mmu_page</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>

    <span class="n">lockdep_assert_held_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">mmu_lock</span><span class="p">);</span>

    <span class="n">role</span> <span class="o">=</span> <span class="n">alloc_tdp_mmu_kpage</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="o">-&gt;</span><span class="n">shadow_root_level</span><span class="p">);</span>
    <span class="n">refcount_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">tdp_mmu_root_count</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

    <span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">tdp_mmu_pages_lock</span><span class="p">);</span>
    <span class="n">list_add_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">tdp_mmu_roots</span><span class="p">);</span>
    <span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kvm</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">tdp_mmu_pages_lock</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">__pa</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">spt</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>相比<code class="language-plaintext highlighter-rouge">kvm_tdp_mmu_get_vcpu_root_hpa</code>，<code class="language-plaintext highlighter-rouge">new_kvm_tdp_mmu_get_vcpu_root_hpa</code>删除了从备用链表中取出页表的链表，强制KVM分配新的物理页。</p> <p>在<code class="language-plaintext highlighter-rouge">vmx_load_mmu_pgd</code>中添加一个<strong>参数</strong>：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">vmx_load_mmu_pgd</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">hpa_t</span> <span class="n">root_hpa</span><span class="p">,</span> <span class="n">hpa_t</span> <span class="o">*</span><span class="n">new_root_hpa</span><span class="p">,</span> <span class="kt">int</span> <span class="n">root_level</span><span class="p">){</span>
<span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">enable_ept</span><span class="p">){</span>
        <span class="n">eptp</span> <span class="o">=</span> <span class="n">construct_eptp</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">root_hpa</span><span class="p">,</span> <span class="n">root_level</span><span class="p">);</span>
        <span class="n">vmcs_write64</span><span class="p">(</span><span class="n">EPT_POINTER</span><span class="p">,</span> <span class="n">eptp</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">eptp_list_pg</span><span class="p">){</span>
			<span class="n">eptp_list</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span> <span class="o">*</span><span class="p">)</span><span class="n">phys_to_virt</span><span class="p">(</span><span class="n">page_to_phys</span><span class="p">(</span><span class="n">to_vmx</span><span class="p">(</span><span class="n">vcpu</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">eptp_list_pg</span><span class="p">));</span>
			<span class="n">eptp_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">eptp</span><span class="p">;</span>

			<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">KVM_EPTP_NUMBERS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
				<span class="n">new_eptp</span> <span class="o">=</span> <span class="n">construct_eptp</span><span class="p">(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">new_root_hpa</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">root_level</span><span class="p">);</span>
				<span class="n">eptp_list</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_eptp</span><span class="p">;</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">"new_eptp: 0x%016llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">new_eptp</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
    <span class="p">}</span>
<span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div> <p>进而需要修改<code class="language-plaintext highlighter-rouge">kvm_mmu_load_pgd</code>：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">kvm_mmu_load_pgd</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvm_vcpu</span> <span class="o">*</span><span class="n">vcpu</span><span class="p">){</span>
<span class="p">...</span>
    <span class="n">new_root_hpa</span> <span class="o">=</span> <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="o">-&gt;</span><span class="n">new_root_hpa</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">KVM_EPTP_NUMBERS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">VALID_PAGE</span><span class="p">(</span><span class="n">new_root_hpa</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">static_call</span><span class="p">(</span><span class="n">kvm_x86_load_mmu_pgd</span><span class="p">)(</span><span class="n">vcpu</span><span class="p">,</span> <span class="n">root_hpa</span><span class="p">,</span> <span class="n">new_root_hpa</span><span class="p">,</span>
 					  <span class="n">vcpu</span><span class="o">-&gt;</span><span class="n">arch</span><span class="p">.</span><span class="n">mmu</span><span class="o">-&gt;</span><span class="n">shadow_root_level</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>注意，由于KVM支持多种体系结构，所以需要同时修改AMD SVM相关函数的参数。</p> <h3 id="虚拟机内调用vmfunc">虚拟机内调用VMFUNC</h3> <p>编写应用程序代码，在虚拟机中运行</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="cp">#define VMX_FUNC ".byte 0x0f,0x01,0xd4" //硬编码VMFUNC的指令
</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">vmfunc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ept</span><span class="p">){</span>
    <span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span>
        <span class="n">VMX_FUNC</span>
        <span class="o">:</span>
        <span class="o">:</span> <span class="s">"a"</span><span class="p">(</span><span class="n">nr</span><span class="p">),</span> <span class="s">"c"</span><span class="p">(</span><span class="n">ept</span><span class="p">)</span>
        <span class="o">:</span> <span class="s">"memory"</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>启动一个线程：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="o">*</span><span class="nf">thread_func</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span> <span class="n">arg</span><span class="p">){</span>
    <span class="n">vmfunc</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">i</span><span class="o">++</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"i = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="n">vmfunc</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="处理ept-violation">处理EPT violation</h3> <p>切换VMFUNC后，执行指令会导致EPT Violation从而陷入到Hypervisor中。需要在Hypervisor中检查当前的EPTP指针，然后遍历<code class="language-plaintext highlighter-rouge">new_root_hpa</code>数组找到指针是否切换，如果指针进行了切换则需要修改页面的root_hpa，使得KVM能够利用EPT violation维护EPT页表。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">eptp</span> <span class="o">=</span> <span class="n">vmcs_read64</span><span class="p">(</span><span class="n">EPT_POINTER</span><span class="p">);</span>
	<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">KVM_EPTP_NUMBERS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
		<span class="k">if</span><span class="p">((</span><span class="n">eptp</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">==</span> <span class="p">((</span><span class="n">mmu</span><span class="o">-&gt;</span><span class="n">new_root_hpa</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)){</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">"[ept_violation]: new_root_hpa[%d] = 0x%llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">mmu</span><span class="o">-&gt;</span><span class="n">new_root_hpa</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">"[ept_violation]: root_hpa = 0x%llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">mmu</span><span class="o">-&gt;</span><span class="n">root_hpa</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">"[ept_violation]: Currenty eptp = 0x%llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">eptp</span><span class="p">);</span>
			<span class="c1">// exchange root_hpa and new_root_hpa[i]</span>
			<span class="n">temp</span> <span class="o">=</span> <span class="n">mmu</span><span class="o">-&gt;</span><span class="n">root_hpa</span><span class="p">;</span>
			<span class="n">mmu</span><span class="o">-&gt;</span><span class="n">root_hpa</span> <span class="o">=</span> <span class="n">mmu</span><span class="o">-&gt;</span><span class="n">new_root_hpa</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">mmu</span><span class="o">-&gt;</span><span class="n">new_root_hpa</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
</code></pre></div></div> <h3 id="结果">结果</h3> <p>能够成功输出：<code class="language-plaintext highlighter-rouge">i = 1</code></p> <p>查看内核debug信息：</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dmesg
</code></pre></div></div> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/book/chapter3/exp2/vmfunc_thread-480.webp 480w,/assets/img/book/chapter3/exp2/vmfunc_thread-800.webp 800w,/assets/img/book/chapter3/exp2/vmfunc_thread-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/book/chapter3/exp2/vmfunc_thread.png" class="img-fluid rounded z-depth-1" width="70%" height="auto" title="vmfunc_thread" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>此时ept_violation处理函数中输出此时的eptp指针为0x1c0f8c05e，正是新创建的eptp。</p> <h1 id="实验三气球模型的充气与放气实现">实验三：气球模型的充气与放气实现</h1> <p><strong>QEMU中增加捕获和修改气球模型的映射页面的功能，并在“放气”时将这些页面重新映射到虚拟机操作系统内核中。</strong></p> <h2 id="背景知识-1">背景知识</h2> <h3 id="使用qemu的balloon功能"><strong>使用QEMU的balloon功能</strong></h3> <ol> <li>正常通过KVM/QEMU启动虚拟机，可以参考实验一<a href="https://gitee.com/silver-zhou/virtualization_book/tree/v-1.0/%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%AE%9E%E9%AA%8C#%E5%88%9B%E5%BB%BA%E5%B9%B6%E5%90%AF%E5%8A%A8%E8%99%9A%E6%8B%9F%E6%9C%BA" rel="external nofollow noopener" target="_blank">第一章实验</a> </li> <li>通过VNC连接到QEMU</li> </ol> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gvncviewer 127.0.0.1::5900
</code></pre></div></div> <ol> <li>通过快捷键<code class="language-plaintext highlighter-rouge">Ctrl+Alt+2</code>切换到QEMU Monitor</li> <li>查看balloon设备信息</li> </ol> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>qemu<span class="o">)</span> info balloon
</code></pre></div></div> <ol> <li>修改虚拟机可用的内存</li> </ol> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>qemu<span class="o">)</span> balloon 2048
</code></pre></div></div> <ul> <li>注意数字单位是MB</li> </ul> <ol> <li>通过快捷键<code class="language-plaintext highlighter-rouge">Ctrl+Alt+2</code>返回到虚拟机图形界面</li> <li>在虚拟机中查看内存使用情况</li> </ol> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>free <span class="nt">-m</span>
</code></pre></div></div> <ol> <li>重复3-7步骤，将虚拟机可用内存修改为4096MB，再次查看内存使用情况</li> </ol> <h3 id="调试qemu"><strong>调试QEMU</strong></h3> <p>在进行QEMU代码修改的时候，可以通过调试的方法检查代码中出现的错误。</p> <ol> <li>确保在编译qemu时开启了debug选项</li> </ol> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./configure <span class="nt">--enable-debug</span>
</code></pre></div></div> <ol> <li>利用qemu启动虚拟机</li> </ol> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>qemu-system-x86_64 <span class="nt">-m</span> 4096 <span class="nt">-smp</span> 4 <span class="nt">--enable-kvm</span> ubuntu.img <span class="nt">-net</span> user,host<span class="o">=</span>10.0.2.10,hostfwd<span class="o">=</span>tcp::10021-:22,hostfwd<span class="o">=</span>tcp::10025-:80 <span class="nt">-net</span> nic <span class="nt">-device</span> virtio-balloon-pci,id<span class="o">=</span>balloon0,bus<span class="o">=</span>pci.0,addr<span class="o">=</span>0x4
</code></pre></div></div> <ol> <li>查看qemu进程的pid</li> </ol> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ps <span class="nt">-aux</span> | <span class="nb">grep </span>qemu
</code></pre></div></div> <ol> <li>GDB调试QEMU</li> </ol> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>gdb qemu-system-x86_64 <span class="o">[</span>pid]
</code></pre></div></div> <ol> <li>GDB中下断点</li> </ol> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>b virtio_balloon_handle_output
</code></pre></div></div> <h3 id="气球模型吸气放气流程">气球模型吸气、放气流程</h3> <h4 id="充气阶段"><strong>充气阶段</strong></h4> <ol> <li> <strong>【宿主机：QEMU】</strong>用户通过QEMU monitor发起气球充气请求</li> <li> <strong>【宿主机：QEMU】</strong>对请求进行处理，通过系统调用进入到KVM，要求KVM向虚拟机注入中断</li> <li> <strong>【宿主机：KVM】</strong>向虚拟机注入中断</li> <li> <strong>【虚拟机】</strong>收到中断，执行中断处理函数，调用气球驱动</li> <li> <strong>【虚拟机】</strong>在气球驱动中申请内存，将申请到的内存的<strong>虚拟机物理地址</strong>和长度用链表进行维护，并且利用virtio协议填入到内存缓冲区中，注册回调函数</li> <li> <strong>【虚拟机】</strong>写MMIO内存陷入到KVM中</li> <li> <strong>【宿主机：KVM】</strong>KVM获取陷入原因，将控制权返回到QEMU中</li> <li> <strong>【宿主机：QEMU】</strong>QEMU根据virtio协议获取虚拟机分配的内存的虚拟机物理地址，并将其转化为宿主机虚拟地址（QEMU进程地址空间）。<font color="red">然后以NONEED为参数进行madvise系统调用释放内存。</font> </li> <li> <strong>【宿主机：QEMU】</strong>通过系统调用进入到KVM，要求KVM向虚拟机注入中断</li> <li> <strong>【宿主机：KVM】</strong>向虚拟机注入中断</li> <li> <strong>【虚拟机】</strong>虚拟机回调函数执行</li> <li> <strong>【虚拟机】</strong>虚拟机继续执行</li> </ol> <h4 id="放气阶段"><strong>放气阶段</strong></h4> <ol> <li> <strong>【宿主机：QEMU】</strong>用户通过QEMU monitor发起气球充气请求</li> <li> <strong>【宿主机：QEMU】</strong>对请求进行处理，通过系统调用进入到KVM，要求KVM向虚拟机注入中断</li> <li> <strong>【宿主机：KVM】</strong>向虚拟机注入中断</li> <li> <strong>【虚拟机】</strong>收到中断，执行中断处理函数，调用气球驱动</li> <li> <strong>【虚拟机】</strong>在气球驱动中将维护的内存取出，并且利用virtio协议填入到内存缓冲区中，注册回调函数</li> <li> <strong>【虚拟机】</strong>写MMIO内存陷入到KVM中</li> <li> <strong>【宿主机：KVM】</strong>KVM获取陷入原因，将控制权返回到QEMU中</li> <li> <strong>【宿主机：QEMU】</strong>QEMU根据virtio协议获取虚拟机分配的内存的虚拟机物理地址，并将其转化为宿主机虚拟地址（QEMU进程地址空间）。<font color="red">然后以WILLNEED为参数进行madvise系统调用。</font> </li> <li> <strong>【宿主机：QEMU】</strong>通过系统调用进入到KVM，要求KVM向虚拟机注入中断</li> <li> <strong>【宿主机：KVM】</strong>向虚拟机注入中断</li> <li> <strong>【虚拟机】</strong>虚拟机回调函数执行</li> <li> <strong>【虚拟机】</strong>虚拟机继续执行</li> </ol> <h2 id="搭建环境">搭建环境</h2> <ol> <li> <p><strong>下载Linux4.14.173源码</strong></p> </li> <li> <p><strong>编译虚拟机内核</strong></p> </li> </ol> <p><strong>为什么需要重新编译虚拟机内核？</strong></p> <p>下载的虚拟机镜像的balloon和内核完整编译到一起，对于balloon的修改不能以模块的方式的进行；重新编译内核后，不需要使用完整的虚拟机镜像即可实现大部分功能。具体编译内核可以参考wiki：<a href="https://gitee.com/silver-zhou/virtualization_book/wikis/%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8%E4%B8%8E%E8%B0%83%E8%AF%95?sort_id=7980385" rel="external nofollow noopener" target="_blank">编译内核与调试 - Wiki - Gitee.com</a></p> <ol> <li><strong>重新编译QEMU</strong></li> </ol> <p>修改qemu的<code class="language-plaintext highlighter-rouge">configure</code>脚本，将madvise配置修改为禁用：</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if </span>compile_prog <span class="s2">""</span> <span class="s2">""</span> <span class="p">;</span> <span class="k">then
	</span><span class="nv">madvise</span><span class="o">=</span><span class="nb">yes
</span><span class="k">fi
</span><span class="nv">madvise</span><span class="o">=</span>no
</code></pre></div></div> <ol> <li><strong>使用新内核以及新编译好的QEMU启动虚拟机</strong></li> </ol> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>qemu-system-x86_64 <span class="se">\</span>
<span class="nt">-s</span>
<span class="nt">-m</span> 4096
<span class="nt">-smp</span> 4
<span class="nt">-enable-kvm</span>
<span class="nt">-kernel</span> <span class="nv">$KERNEL</span>/bzImage <span class="c">#指定内核镜像</span>
<span class="nt">-append</span> <span class="s2">"root=/dev/sda kgdboc=ttyS0,115200 net.ifnames=0 kvm_intel"</span> <span class="c">#指定启动参数，开启了</span>
<span class="nt">-drive</span> <span class="nv">file</span><span class="o">=</span>stretch.img,format<span class="o">=</span>raw <span class="c">#指定文件系统</span>
<span class="nt">-serial</span> tcp::4321,server,nowait <span class="c">#指定串口</span>
<span class="nt">-net</span> user,host<span class="o">=</span>10.0.2.10,hostfwd<span class="o">=</span>tcp::10021-:22,hostfwd<span class="o">=</span>tcp::10025-:80 <span class="c">#指定端口映射，将22（ssh）映射到宿主机的10021，将80（http）映射到宿主机的10025</span>
<span class="nt">-net</span> nic,model<span class="o">=</span>e1000
<span class="nt">-device</span> virtio-balloon-pci,id<span class="o">=</span>balloon0,bus<span class="o">=</span>pci.0,addr<span class="o">=</span>0x4
</code></pre></div></div> <h2 id="解决思路-2">解决思路</h2> <ol> <li>在虚拟机申请内存后<u>（上文充气阶段步骤5）</u>，向内存写入数据“before inflate”；</li> <li>在QEMU中找到处理气球充气时的处理函数<u>（上文充气阶段步骤8）</u>，输出虚拟机写入的数据，并向内存写入新的数据；</li> <li>在QEMU中取消气球充气时，内存的释放（注：在上文环境搭建步骤3中，已经将QEMU的madvise配置选项修改为了关闭，所以不需要再对应的修改代码）；</li> <li>在虚拟机内核中找到处理气球放气时的处理函数<u>（上文放气阶段步骤11）</u>，输出内存中的信息。</li> </ol> <h2 id="实验-2">实验</h2> <h3 id="虚拟机内写入数据">虚拟机内写入数据</h3> <p>在<code class="language-plaintext highlighter-rouge">balloon_page_alloc</code>函数中：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="nf">balloon_page_alloc</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">balloon_mapping_gfp_mask</span><span class="p">()</span> <span class="o">|</span> <span class="n">__GFP_NOMEMALLOC</span> <span class="o">|</span> <span class="n">__GFP_NORETRY</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">),</span> <span class="s">"before inflate</span><span class="se">\0</span><span class="s">"</span><span class="p">,</span> <span class="mi">15</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">page</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="qemu中拦截页面信息">QEMU中拦截页面信息</h3> <p>在<code class="language-plaintext highlighter-rouge">ram_block_discard_range</code>中，输出虚拟机写入的数据，并且修改内存上的数据。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="n">need_madvise</span><span class="p">){</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"data = %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">host_startaddr</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">host_startaddr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">host_startaddr</span><span class="p">,</span> <span class="s">"after deflate"</span><span class="p">,</span> <span class="mi">13</span><span class="p">);</span>
<span class="k">if</span> <span class="n">defined</span><span class="p">(</span><span class="n">CONFIG_MADVISE</span><span class="p">)</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">madvise</span><span class="p">(</span><span class="n">host_startaddr</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">MADV_DONTNEED</span><span class="p">);</span><span class="c1">//这段代码将不会被执行到</span>
<span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div> <p>有关于madvise系统调用，可以参考wiki：https://gitee.com/silver-zhou/virtualization_book/wikis/madvise%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8?sort_id=7986141</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/book/chapter3/exp3/balloon_inflate_page-480.webp 480w,/assets/img/book/chapter3/exp3/balloon_inflate_page-800.webp 800w,/assets/img/book/chapter3/exp3/balloon_inflate_page-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/book/chapter3/exp3/balloon_inflate_page.png" class="img-fluid rounded z-depth-1" width="70%" height="auto" title="balloon inflate page" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <h3 id="修改虚拟机内核输出页面重映射数据">修改虚拟机内核，输出页面重映射数据</h3> <p>在<code class="language-plaintext highlighter-rouge">release_pages_balloon</code>中，将页面上的数据输出：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="o">*</span> <span class="n">page_addr</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">data</span><span class="p">[</span><span class="mi">30</span><span class="p">];</span>

<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">pages</span><span class="p">,</span> <span class="n">lru</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">page_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span> <span class="c1">//通过内核函数page_address将page指针转换为虚拟地址</span>

    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4096</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">page_addr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="n">printk</span><span class="p">(</span><span class="s">"data = %c</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
    <span class="n">printk</span><span class="p">(</span><span class="s">"data = %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/book/chapter3/exp3/balloon_deflate_guest-480.webp 480w,/assets/img/book/chapter3/exp3/balloon_deflate_guest-800.webp 800w,/assets/img/book/chapter3/exp3/balloon_deflate_guest-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/book/chapter3/exp3/balloon_deflate_guest.png" class="img-fluid rounded z-depth-1" width="70%" height="auto" title="balloon deflate guest" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/book/2025/lab2/">第二章实验</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/book/2025/lab1/">第一章实验</a> </li> <div id="giscus_thread" style="max-width: 1600px; margin: 0 auto;"> <script>
      let giscusTheme = determineComputedTheme();
      let giscusAttributes = {
        src: 'https://giscus.app/client.js',
        'data-repo': 'DAMS-Group/DAMS-Group.github.io',
        'data-repo-id': 'R_kgDOOirvnQ',
        'data-category': 'Announcements',
        'data-category-id': 'DIC_kwDOOirvnc4Cpr6o',
        'data-mapping': 'title',
        'data-strict': '1',
        'data-reactions-enabled': '1',
        'data-emit-metadata': '0',
        'data-input-position': 'top',
        'data-theme': giscusTheme,
        'data-lang': 'zh-CN',
        'data-loading': 'lazy',
        crossorigin: 'anonymous',
        async: '',
      };

      let giscusScript = document.createElement('script');
      Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value));
      document.getElementById('giscus_thread').appendChild(giscusScript);
    </script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025. 分布式与移动系统安全实验室. All rights reserved. Last updated: May 13, 2025. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>